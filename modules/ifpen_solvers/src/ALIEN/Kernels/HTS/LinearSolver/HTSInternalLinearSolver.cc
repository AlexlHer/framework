
/* Author : desrozis at Mon Mar 30 15:06:37 2009
 * Generated by createNew
 */
#define MPICH_SKIP_MPICXX 1
#include "mpi.h"

#include <vector>

#include "ALIEN/Kernels/HTS/HTSPrecomp.h"

#ifdef ALIEN_USE_HARTS
#include "HARTS/HARTS.h"
#endif

#ifdef ALIEN_USE_HTSSOLVER
#include "HARTSSolver/HTS.h"
#include "HARTSSolver/MatrixVector/CSR/CSRProfileImpT.h"
#include "HARTSSolver/MatrixVector/CSR/CSRMatrixImpT.h"
#endif

#include <alien/data/Space.h>
#include <alien/expression/solver/ILinearSolver.h>
#include <alien/expression/solver/ILinearAlgebra.h>
#include <alien/expression/solver/solver_stats/SolverStat.h>
#include <alien/expression/solver/solver_stats/SolverStater.h>

#include <alien/kernels/simple_csr/SimpleCSRPrecomp.h>
#include <alien/kernels/simple_csr/algebra/SimpleCSRLinearAlgebra.h>

#include <ALIEN/Kernels/HTS/Algebra/HTSLinearAlgebra.h>
#include <alien/core/impl/MultiMatrixImpl.h>
#include <alien/core/impl/MultiVectorImpl.h>


#include <ALIEN/Kernels/HTS/Algebra/HTSLinearAlgebra.h>
#include <ALIEN/Kernels/HTS/LinearSolver/HTSInternalLinearSolver.h>
#include <alien/core/backend/LinearSolverT.h>
#include <alien/core/block/ComputeBlockOffsets.h>
#include <ALIEN/axl/HTSSolver_IOptions.h>
#include <arccore/message_passing_mpi/MpiMessagePassingMng.h>


/*---------------------------------------------------------------------------*/

namespace Alien {

// Compile HTSLinearSolver.
// template class ALIEN_IFPEN_SOLVERS_EXPORT LinearSolver<BackEnd::tag::htssolver>;

/*---------------------------------------------------------------------------*/
HTSInternalLinearSolver::HTSInternalLinearSolver(
    Arccore::MessagePassing::IMessagePassingMng* parallel_mng, IOptionsHTSSolver* options)
: m_parallel_mng(parallel_mng)
, m_options(options)
{}


void
HTSInternalLinearSolver::init(int argc, char const** argv)
{
#ifdef ALIEN_USE_HTSSOLVER
  m_hts_solver.reset(new HartsSolver::HTSSolver()) ;
#endif
}


/*---------------------------------------------------------------------------*/

void
HTSInternalLinearSolver::init()
{
  SolverStatSentry<HTSInternalLinearSolver> sentry(this,SolverStater::eInit) ;
  m_output_level = m_options->output();

#ifdef ALIEN_USE_HTSSOLVER
  m_use_mpi = m_parallel_mng->commSize() > 1;
  m_machine_info.init(m_parallel_mng->commRank() == 0);

  m_hts_solver.reset(new HartsSolver::HTSSolver());
  m_hts_solver->setMachineInfo(&m_machine_info);

  bool use_simd = m_options->useSimd() ;
  m_runtime_configuration.m_memory_space.m_is_mpi      = m_use_mpi ;
  m_runtime_configuration.m_execution_space.m_use_simd = use_simd ;
  switch(m_options->threadEnvType())
  {
    case 0:
      m_runtime_configuration.m_execution_space.m_thread_env_type = HARTS::PTh ;
      break ;
    case 1:
      m_runtime_configuration.m_execution_space.m_thread_env_type = HARTS::OpenMP ;
      break ;
    default :
      m_runtime_configuration.m_execution_space.m_thread_env_type = HARTS::PTh ;
      break ;
  }
#endif
  m_current_ctx_id = m_hts_solver->createNewContext();
  HartsSolver::HTSSolver::ContextType& context = m_hts_solver->getContext(m_current_ctx_id) ;

  typedef HartsSolver::MPIInfo MPIEnvType ;
  if (m_use_mpi)
  {
    auto* mpi_mng = dynamic_cast<Arccore::MessagePassing::Mpi::MpiMessagePassingMng*>(m_parallel_mng);
    MPI_Comm comm = *static_cast<const MPI_Comm*>(mpi_mng->getMPIComm());
    MPIEnvType* mpi_env = new HartsSolver::MPIInfo() ;
    mpi_env->init(comm, false); // external MPI management
    context.set<MPIEnvType>(HartsSolver::HTSSolver::Context::MPIEnv,mpi_env) ;
  }

  m_hts_solver->setCurrentContext(&context) ;

  m_hts_solver->setParameter<int>("output",m_output_level) ;
  m_hts_solver->setParameter<int>("parallel-trace",m_options->parallelTrace()) ;

  if(m_options->normalizeOpt())
     m_hts_solver->setParameter<int>("normalize-opt",1) ;
  m_hts_solver->setParameter<int>("max-iteration",m_options->maxIterationNum()) ;
  m_hts_solver->setParameter<double>("tol",m_options->stopCriteriaValue()) ;
  m_hts_solver->setParameter<int>("solver",(int)m_options->solver()) ;
  m_hts_solver->setParameter<int>("precond-type",(int)m_options->preconditioner());
  switch(m_options->preconditioner())
  {
  case HTSOptionTypes::Poly:
  case HTSOptionTypes::Chebyshev:
     m_hts_solver->setParameter<double>("poly-factor",          m_options->polyFactor()) ;
     m_hts_solver->setParameter<double>("poly-eigenvalue-ratio",m_options->polyEigenvalueRatio()) ;
     m_hts_solver->setParameter<double>("poly-eigenvalue-max",  m_options->polyEigenvalueMax()) ;
     m_hts_solver->setParameter<double>("poly-eigenvalue-min",  m_options->polyEigenvalueMin()) ;

     m_hts_solver->setParameter<int>("poly-degree",             m_options->polyDegree()) ;
     m_hts_solver->setParameter<int>("poly-factor-max-iter",    m_options->polyFactorMaxIter()) ;
     break ;
  case HTSOptionTypes::ILU0FP:
     m_hts_solver->setParameter<int>("ilufp-factor-niter",m_options->ilufpFactorNiter()) ;
     m_hts_solver->setParameter<int>("ilufp-solver-niter",m_options->ilufpSolverNiter()) ;
     m_hts_solver->setParameter<double>("ilufp-tol",m_options->ilufpTol()) ;
     break ;
  case HTSOptionTypes::Cpr:
  case HTSOptionTypes::DDMLPC:
    if(m_options->mlOpt().size()>0)
    {
      auto const& opt = m_options->mlOpt()[0] ;
      m_hts_solver->setParameter<int>   ("ml-output",             opt->output()) ;
      m_hts_solver->setParameter<int>   ("ml",                    opt->algo()) ;
      m_hts_solver->setParameter<int>   ("ml-iter",               opt->iter()) ;
      m_hts_solver->setParameter<double>("ml-tol",                opt->tol()) ;
      m_hts_solver->setParameter<int>   ("ml-nev",                opt->nev()) ;
      m_hts_solver->setParameter<int>   ("ml-evtype",             opt->evtype()) ;
      m_hts_solver->setParameter<double>("ml-evbound",            opt->evbound()) ;
      m_hts_solver->setParameter<double>("ml-evtol",              opt->evtol()) ;
      m_hts_solver->setParameter<int>   ("ml-ev-max-iter",        opt->evMaxIter()) ;
      m_hts_solver->setParameter<int>   ("ml-coarse-op",          opt->coarseOp()) ;
      m_hts_solver->setParameter<int>   ("ml-solver",             opt->solver()) ;
      m_hts_solver->setParameter<int>   ("ml-solver-iter",        opt->solverIter()) ;
      m_hts_solver->setParameter<double>("ml-solver-tol",         opt->solverTol()) ;
      m_hts_solver->setParameter<int>   ("ml-solver-nev",         opt->solverNev()) ;
      m_hts_solver->setParameter<int>   ("ml-coarse-solver",      opt->coarseSolver()) ;
      m_hts_solver->setParameter<int>   ("ml-coarse-solver-ntile",opt->coarseSolverNtile()) ;
      m_hts_solver->setParameter<int>   ("ml-neumann-cor",        opt->neumannCor()) ;
      m_hts_solver->setParameter<int>   ("ilu-level",   m_options->iluLevel()) ;
      m_hts_solver->setParameter<double>("ilu-drop-tol",m_options->iluDropTol()) ;
    }
    break ;
  case HTSOptionTypes::AMGPC:
  case HTSOptionTypes::CprAMG:
  case HTSOptionTypes::CprDDML:
  default :
    break;
  }
  if(m_options->useThread())
     m_hts_solver->setParameter<int>("use-thread",1) ;
  m_hts_solver->setParameter<int>("nb-threads",  m_options->nbThreads()) ;
  m_hts_solver->setParameter<int>("nb-part",     m_options->nbPart()) ;
  m_hts_solver->setParameter<int>("nb-subpart",  m_options->nbSubpart()) ;
  m_hts_solver->setParameter<int>("metis",       m_options->metis()) ;
  m_hts_solver->setParameter<int>("smetis",      m_options->smetis()) ;
  m_hts_solver->setParameter<int>("sendrecv-opt",m_options->sendrecvOpt()) ;
  m_hts_solver->setParameter<int>("pqueue",      m_options->pqueue()) ;
  m_hts_solver->setParameter<int>("affinity-mode",m_options->affinityMode()) ;


}

void
HTSInternalLinearSolver::updateParallelMng(Arccore::MessagePassing::IMessagePassingMng* pm)
{
  m_parallel_mng = pm;
}

/*---------------------------------------------------------------------------*/

void
HTSInternalLinearSolver::end()
{
}



#ifdef ALIEN_USE_HTSSOLVER
bool HTSInternalLinearSolver::solve(CSRMatrixType const& A,
                                    CSRVectorType const& b,
                                    CSRVectorType& x)
{
  using namespace HartsSolver ;

  if(m_output_level>0)
    alien_info([&] { cout()<<"HTSLinearSolver::solve"; } ) ;

  _startPerfCount();

  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  //
  // GET CURRENT CONTEXT
  //
  HartsSolver::HTSSolver::ContextType& context = m_hts_solver->getContext(m_current_ctx_id) ;
  m_hts_solver->setCurrentContext(&context) ;

  bool is_parallel = false ;
  auto* parallel_mng = A.distribution().parallelMng();
  if(parallel_mng)
    is_parallel = parallel_mng->commSize() > 1 ;
  typedef HartsSolver::MPIInfo MPIEnvType ;
  MPIEnvType* mpi_env = nullptr ;
  if(is_parallel)
  {
    mpi_env = context.get<MPIEnvType>(HTSSolver::Context::MPIEnv) ;
    if(mpi_env==nullptr)
    {
      auto* mpi_mng = dynamic_cast<Arccore::MessagePassing::Mpi::MpiMessagePassingMng*>(m_parallel_mng);
      MPI_Comm comm = *static_cast<const MPI_Comm*>(mpi_mng->getMPIComm());
      MPIEnvType* mpi_env = new HartsSolver::MPIInfo() ;
      mpi_env->init(comm, false); // external MPI management
      context.set<MPIEnvType>(HTSSolver::Context::MPIEnv,mpi_env) ;
    }
  }
  ///////////////////////////////////////////////
  //
  // GET CURRENT PROFILE
  //

  typedef HartsSolver::CSRProfile             MCProfileType ;
  typedef HartsSolver::ProfileView            MCProfileViewType ;
  typedef MCProfileType::PermutationType    MCProfilePermType ;

  CSRMatrixType::ProfileType const& matrix_profile = A.internal().getCSRProfile() ;
  int nrows = matrix_profile.getNRow() ;
  int const* kcol = matrix_profile.getRowOffset().unguardedBasePointer() ;
  int const* cols = matrix_profile.getCols().unguardedBasePointer() ;


  typedef Graph::MPIPartition MPIPartitionType ;
  MPIPartitionType* partition_info = context.get<MPIPartitionType>(HTSSolver::Context::MPIPartition) ;
  if(is_parallel && partition_info==NULL)
  {
    Graph::MPIPartition* mpi_partition = new Graph::MPIPartition(mpi_env->getParallelMng()) ;
    mpi_partition->init(nrows) ;
    MCProfileViewType profile(kcol,cols,nrows) ;
    mpi_partition->compute(profile,true) ;
    partition_info = mpi_partition  ;
    context.set<MPIPartitionType>(HTSSolver::Context::MPIPartition,partition_info) ;
  }


  ////////////////////////////////////////////////////
  //
  // SOLVE
  //
  Integer error = 0 ;
  MCProfileType* profile = context.get<MCProfileType>(HTSSolver::Context::MatrixProfile) ;
  MCProfilePermType* profile_permutation = NULL ;
  if(profile==NULL)
  {
    if(partition_info)
    {
      profile_permutation = new MCProfilePermType(*partition_info) ;
      context.set<MCProfilePermType>(HTSSolver::Context::ProfilePermutation,profile_permutation) ;
    }
    if(profile_permutation)
    {
      profile = new MCProfileType() ;
      profile->init(nrows,kcol,cols,*profile_permutation) ;
    }
    else
      profile = new MCProfileType(nrows,kcol,cols) ;
    context.set<MCProfileType>(HTSSolver::Context::MatrixProfile,profile) ;
  }
  //int block_size =  A.space().structInfo().size() ;
  int block_size = A.block() ? A.block()->size() : 1 ;
  switch(block_size)
  {
  case 1:
    {
      typedef HartsSolver::CSRMatrix<Real,1>      MCMatrixType ;
      MCMatrixType matrix(profile) ;
      matrix.setValues(A.internal().getDataPtr(),profile_permutation) ;
      //matrix.updateValues(nrows,kcol,block_size,A.internal().getDataPtr()) ;
      RunOp op(m_hts_solver.get(),matrix,b.getDataPtr(),x.getDataPtr(),m_hts_status,context);
      HARTS::DispatchRun<RunOp>(m_runtime_configuration,op) ;
    }
    break ;
  case 2:
    {
      typedef HartsSolver::CSRMatrix<Real,2>      MCMatrixType ;
      typedef MCMatrixType::MatrixDataType      MatrixDataType ;
      typedef MCMatrixType::VectorDataType      VectorDataType ;
      MCMatrixType matrix(profile) ;
      matrix.setValues((MatrixDataType const*)(A.internal().getDataPtr()),profile_permutation) ;
      //matrix.updateValues(nrows,kcol,block_size,A.internal().getDataPtr()) ;
      if(is_parallel)
        error = m_hts_solver->solveN<2,true>(matrix,
                                            reinterpret_cast<VectorDataType const*>(b.getDataPtr()),
                                            reinterpret_cast<VectorDataType*>(x.getDataPtr()),
                                            m_hts_status,context) ;
      else
        error = m_hts_solver->solveN<2,false>(matrix,
                         reinterpret_cast<VectorDataType const*>(b.getDataPtr()),
                         reinterpret_cast<VectorDataType*>(x.getDataPtr()),
                         m_hts_status,context) ;
    }
    break ;
  case 3:
    {
      typedef HartsSolver::CSRMatrix<Real,3>      MCMatrixType ;
      typedef MCMatrixType::MatrixDataType      MatrixDataType ;
      typedef MCMatrixType::VectorDataType      VectorDataType ;
      MCMatrixType matrix(profile) ;
      matrix.setValues((MatrixDataType const*)(A.internal().getDataPtr()),profile_permutation) ;
      //matrix.updateValues(nrows,kcol,block_size,A.internal().getDataPtr()) ;
      if(is_parallel)
    error = m_hts_solver->solveN<3,true>(matrix,
                        reinterpret_cast<VectorDataType const*>(b.getDataPtr()),
                        reinterpret_cast<VectorDataType*>(x.getDataPtr()),
                        m_hts_status,context) ;
      else
        error = m_hts_solver->solveN<3,false>(matrix,
                         reinterpret_cast<VectorDataType const*>(b.getDataPtr()),
                         reinterpret_cast<VectorDataType*>(x.getDataPtr()),
                         m_hts_status,context) ;
    }
    break ;
  case 4:
    {
      typedef HartsSolver::CSRMatrix<Real,4>      MCMatrixType ;
      typedef MCMatrixType::MatrixDataType      MatrixDataType ;
      typedef MCMatrixType::VectorDataType      VectorDataType ;
      MCMatrixType matrix(profile) ;
      matrix.setValues((MatrixDataType const*)(A.internal().getDataPtr()),profile_permutation) ;
      //matrix.updateValues(nrows,kcol,block_size,A.internal().getDataPtr()) ;
      if(is_parallel)
        error = m_hts_solver->solveN<4,true>(matrix,
                                            reinterpret_cast<VectorDataType const*>(b.getDataPtr()),
                                            reinterpret_cast<VectorDataType*>(x.getDataPtr()),
                                            m_hts_status,context) ;
      else
        error = m_hts_solver->solveN<4,false>(matrix,
                         reinterpret_cast<VectorDataType const*>(b.getDataPtr()),
                         reinterpret_cast<VectorDataType*>(x.getDataPtr()),
                         m_hts_status,context) ;
    }
    break ;
  default :
    break ;
  }

  _endPerfCount();

  ////////////////////////////////////////////////////
  //
  // ANALIZE STATUS
  m_status.residual = m_hts_status.residual ;
  m_status.iteration_count = m_hts_status.num_iter ;

  if(error==0)
  {
    m_status.succeeded = true ;
    m_status.error = 0 ;
    if(m_output_level>0)
    {
      alien_info([&] {
        cout()<<"Resolution info      :";
        cout()<<"Resolution status      : OK";
        cout()<<"Residual             : "<<m_hts_status.residual ;
        cout()<<"Number of iterations : "<<m_hts_status.num_iter ;
      }) ;
    }
    return true ;
  }
  else
  {
    m_status.succeeded = false ;
    m_status.error = m_hts_status.error ;
    if(m_output_level>0)
    {
      alien_info([&] {
        cout()<<"Resolution status      : Error";
        cout()<<"Error code             : "<<m_hts_status.error ;
      }) ;
    }
    return false ;
  }
}
#endif


void
HTSInternalLinearSolver::
_startPerfCount()
{
}

/*---------------------------------------------------------------------------*/

void
HTSInternalLinearSolver::
_endPerfCount()
{
  m_solve_num++;
  m_total_iter_num += m_status.iteration_count;

}


const Alien::SolverStatus&
HTSInternalLinearSolver::
getStatus() const
{
  if(m_output_level>0)
  {
    printInfo();
  }
  return m_status;
}

void
HTSInternalLinearSolver::
printInfo()
{
  alien_info([&] {
      cout();
      cout()<<"|--------------------------------------------|";
      cout()<<"| Linear Solver        : HTSSolver           |";
      cout()<<"|--------------------------------------------|";
      cout()<<"| total solver time    : "<<m_total_solve_time;
      cout()<<"| total system time    : "<<m_total_system_time;
      cout()<<"| total num of iter    : "<<m_total_iter_num;
      cout()<<"| solve num            : "<<m_solve_num;
      cout()<<"| internal setup time  : "<<m_int_total_setup_time;
      cout()<<"| internal solve time  : "<<m_int_total_solve_time;
      cout()<<"| internal finish time : "<<m_int_total_finish_time;
      cout()<<"|---------------------------------------------|";
      cout();
    });
}

void
HTSInternalLinearSolver::
printInfo() const
{
  alien_info([&] {
      cout();
      cout()<<"|--------------------------------------------|";
      cout()<<"| Linear Solver        : HTSSolver           |";
      cout()<<"|--------------------------------------------|";
      cout()<<"| total solver time    : "<<m_total_solve_time;
      cout()<<"| total system time    : "<<m_total_system_time;
      cout()<<"| total num of iter    : "<<m_total_iter_num;
      cout()<<"| solve num            : "<<m_solve_num;
      cout()<<"| internal setup time  : "<<m_int_total_setup_time;
      cout()<<"| internal solve time  : "<<m_int_total_solve_time;
      cout()<<"| internal finish time : "<<m_int_total_finish_time;
      cout()<<"|---------------------------------------------|";
      cout();
    });
}


bool
HTSInternalLinearSolver::
solve(IMatrix const& A, IVector const& b, IVector& x)
{
  using namespace Alien;

#ifdef ALIEN_USE_HTSSOLVER
    SolverStatSentry<HTSInternalLinearSolver> sentry(this,SolverStater::ePrepare) ;
    CSRMatrixType const& matrix = A.impl()->get<BackEnd::tag::simplecsr>() ;
    CSRVectorType const& rhs = b.impl()->get<BackEnd::tag::simplecsr>() ;
    CSRVectorType& sol = x.impl()->get<BackEnd::tag::simplecsr>(true) ;
    sentry.release() ;

    SolverStatSentry<HTSInternalLinearSolver> sentry2(this,SolverStater::eSolve) ;
    return solve(matrix,rhs,sol) ;
#endif
}

std::shared_ptr<ILinearAlgebra>
HTSInternalLinearSolver::
algebra() const
{
  return std::shared_ptr<ILinearAlgebra>(new Alien::HTSLinearAlgebra());
}
/*
IInternalLinearSolver<SimpleCSRMatrix<Real>, SimpleCSRVector<Real> >*
HTSInternalLinearSolverFactory(IParallelMng* p_mng, IOptionsHTSSolver* options)
{
  return new HTSInternalLinearSolver(p_mng, options);
}*/
ILinearSolver*
HTSInternalLinearSolverFactory(Arccore::MessagePassing::IMessagePassingMng* p_mng, IOptionsHTSSolver* options)
{
  return new HTSInternalLinearSolver(p_mng, options);
}
} // namespace Alien
