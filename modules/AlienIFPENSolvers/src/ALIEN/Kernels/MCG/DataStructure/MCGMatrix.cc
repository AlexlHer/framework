#include "mpi.h"
#include "MCGMatrix.h"
/* Author : mesriy at Tue Jul 24 15:56:45 2012
 * Generated by createNew
 */

#include <ALIEN/Kernels/MCG/LinearSolver/GPUInternal.h>
#include <ALIEN/Kernels/MCG/DataStructure/MCGInternal.h>

#include <alien/core/impl/MultiMatrixImpl.h>

/*---------------------------------------------------------------------------*/


BEGIN_MCGINTERNAL_NAMESPACE

template<>
CSRStruct<1>&
MatrixInternal::getCSRStruct<1>() {
  return m_csr_b1 ;
}

template<>
CSRStruct<1> const&
MatrixInternal::getCSRStruct<1>() const{
  return m_csr_b1 ;
}

template<>
CSRStruct<2>&
MatrixInternal::getCSRStruct<2>() {
  return m_csr_b2 ;
}

template<>
CSRStruct<2> const&
MatrixInternal::getCSRStruct<2>() const {
  return m_csr_b2 ;
}

template<>
CSRStruct<3>&
MatrixInternal::getCSRStruct<3>() {
  return m_csr_b3 ;
}

template<>
CSRStruct<3> const&
MatrixInternal::getCSRStruct<3>() const {
  return m_csr_b3 ;
}

template<>
CSRStruct<4>&
MatrixInternal::getCSRStruct<4>() {
  return m_csr_b4 ;
}

template<>
CSRStruct<4> const&
MatrixInternal::getCSRStruct<4>() const{
  return m_csr_b4 ;
}

END_MCGINTERNAL_NAMESPACE

namespace Alien {

/*---------------------------------------------------------------------------*/

MCGMatrix::MCGMatrix(const MultiMatrixImpl* multi_impl)
: IMatrixImpl(multi_impl, AlgebraTraits<BackEnd::tag::mcgsolver>::name())
, m_internal(NULL)
, m_equations_num(0)
, m_unknowns_num(0)
, m_block_size(0)
, m_domain_offset(0)
  , m_space0(NULL)
  , m_space1(NULL)
{
  ;
}

/*---------------------------------------------------------------------------*/

MCGMatrix::~MCGMatrix()
{
  delete m_internal ;
}

/*---------------------------------------------------------------------------*/

bool 
MCGMatrix::
initMatrix(int nrow,
           int const* row_offset,
           int const* cols)
{
  delete m_internal ;
  m_internal = new MatrixInternal() ;
  m_internal->m_equations_num = m_equations_num ;
  Integer nblocks = row_offset[nrow] ;
  m_internal->m_struct = new GPUInternal::MatrixStruct(nrow,nrow,nblocks,(int*)row_offset,(int*)cols,m_domain_offset) ;
  m_row_offset1 = row_offset;
  return true ;
}

template<>
MCGInternal::CSRStruct<1>&
MCGMatrix::getCSRStruct<1>() {
  return m_internal->m_csr_b1 ;
}

template<>
MCGInternal::CSRStruct<1> const&
MCGMatrix::getCSRStruct<1>() const{
  return m_internal->m_csr_b1 ;
}

template<>
MCGInternal::CSRStruct<2>&
MCGMatrix::getCSRStruct<2>() {
  return m_internal->m_csr_b2 ;
}

template<>
MCGInternal::CSRStruct<2> const&
MCGMatrix::getCSRStruct<2>() const {
  return m_internal->m_csr_b2 ;
}

template<>
MCGInternal::CSRStruct<3>&
MCGMatrix::getCSRStruct<3>() {
  return m_internal->m_csr_b3 ;
}

template<>
MCGInternal::CSRStruct<3> const&
MCGMatrix::getCSRStruct<3>() const {
  return m_internal->m_csr_b3 ;
}

template<>
MCGInternal::CSRStruct<4>&
MCGMatrix::getCSRStruct<4>() {
  return m_internal->m_csr_b4 ;
}

template<>
MCGInternal::CSRStruct<4> const&
MCGMatrix::getCSRStruct<4>() const{
  return m_internal->m_csr_b4 ;
}

bool
MCGMatrix::initMatrixValues(int nrow,
                            int const* row_offset,
                            int const* cols,
                            Real const* values)
{

  switch(m_equations_num)
  {
    case 1 :
      getCSRStruct<1>().init(m_internal->m_struct,values) ;
      break ;
    case 2 :
      getCSRStruct<2>().init(m_internal->m_struct,values) ;
      break ;
    case 3 :
      getCSRStruct<3>().init(m_internal->m_struct,values) ;
      break ;
    case 4 :
      getCSRStruct<4>().init(m_internal->m_struct,values) ;
      break ;
  }
  return true ;
}
/*---------------------------------------------------------------------------*/

bool 
MCGMatrix::
addMatrixValues(const int nrow,
                const int * rows,
                const int * row_offset,
                const int * cols,
                const double * values)
{ 
  MCGInternal::checkParallel(this->distribution().isParallel());

  return true ;
}

bool
MCGMatrix::
initSubMatrix01( int nrow,
                 int nb_extra_eq,
                 int const* row_offset,
                 int const* cols)
{
  Integer nblocks = row_offset[nb_extra_eq] ;
  m_internal->m_extra_block01_struct =
      new GPUInternal::MatrixStruct(nb_extra_eq,
                                    nrow,
                                    nblocks,
                                    (int*)row_offset,
                                    (int*)cols,
                                    m_domain_offset) ;
  m_row_offset2 = row_offset;
return true ;
}

bool
MCGMatrix::
initSubMatrix11(int nb_extra_eq,
                int const* row_offset,
                int const* cols)
{
  Integer nblocks = row_offset[nb_extra_eq] ;
  m_internal->m_extra_block11_struct =
      new GPUInternal::MatrixStruct(nb_extra_eq,
                                    nb_extra_eq,
                                    nblocks,
                                    (int*)row_offset,
                                    (int*)cols) ;
  m_row_offset4 = row_offset;
  return true ;
}


bool
MCGMatrix::
initSubMatrix11Values( Real const* ExtraDiagValues)
{
  m_internal->m_cmatrix =
      new MatrixInternal::MatrixB1(m_internal->m_extra_block11_struct,
                                   (MatrixInternal::MatrixB1Value*)ExtraDiagValues) ;
  return true ;
}

bool
MCGMatrix::
initSubMatrix10Values( Real const* ExtraRowValues)
{
  switch(m_equations_num)
  {
    case 1 :
      getCSRStruct<1>().initExtraEqRow(m_internal->m_extra_block01_struct,ExtraRowValues) ;
      break ;
    case 2 :
      getCSRStruct<2>().initExtraEqRow(m_internal->m_extra_block01_struct,ExtraRowValues) ;
      break ;
    case 3 :
      getCSRStruct<3>().initExtraEqRow(m_internal->m_extra_block01_struct,ExtraRowValues) ;
      break ;
    case 4 :
      getCSRStruct<4>().initExtraEqRow(m_internal->m_extra_block01_struct,ExtraRowValues) ;
      break ;
  }

  return true ;
}

bool
MCGMatrix::
initSubMatrix01Values( Real const* ExtraColValues)
{
  switch(m_equations_num)
  {
    case 1 :
      getCSRStruct<1>().initExtraEqCol(m_internal->m_extra_block01_struct,ExtraColValues) ;
      break ;
    case 2 :
      getCSRStruct<2>().initExtraEqCol(m_internal->m_extra_block01_struct,ExtraColValues) ;
      break ;
    case 3 :
      getCSRStruct<3>().initExtraEqCol(m_internal->m_extra_block01_struct,ExtraColValues) ;
      break ;
    case 4 :
      getCSRStruct<4>().initExtraEqCol(m_internal->m_extra_block01_struct,ExtraColValues) ;
      break ;
  }
  return true ;
}

int const* MCGMatrix::get_row_offset1() const
{
  return m_row_offset1;
}

int const* MCGMatrix::get_row_offset2() const
{
  return m_row_offset2;
}
/*---------------------------------------------------------------------------*/

} // namespace Alien

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

