/* Author : desrozis at Mon Mar 30 15:06:37 2009
 * Generated by createNew
 */
#define MPICH_SKIP_MPICXX 1
#include "mpi.h"

#include "MCGS.h"

#include "ALIEN/Kernels/MCG/MCGPrecomp.h"

#ifdef USE_HARTS
#include "MatrixVector/ProfilePermutation.h"
#include "MatrixVector/CSRProfile.h"
#include "MatrixVector/CSRProfileImpT.h"
#include "MatrixVector/CSRMatrixImpT.h"
#endif

#include <ALIEN/Data/Space.h>
#include <ALIEN/Expression/Solver/ILinearSolver.h>
#include <ALIEN/Expression/Solver/ILinearAlgebra.h>
#include <ALIEN/Expression/Solver/SolverStats/SolverStat.h>
#include <ALIEN/Expression/Solver/SolverStats/SolverStater.h>
#include <ALIEN/Kernels/MCG/Algebra/MCGLinearAlgebra.h>
#include <ALIEN/Core/Impl/MultiMatrixImpl.h>
#include <ALIEN/Core/Impl/MultiVectorImpl.h>
#include <ALIEN/Kernels/SimpleCSR/SimpleCSRPrecomp.h>
#include <ALIEN/Kernels/SimpleCSR/Algebra/SimpleCSRLinearAlgebra.h>
#include <ALIEN/Kernels/MCG/LinearSolver/GPUInternal.h>
#include <ALIEN/Kernels/MCG/DataStructure/MCGVector.h>
#include <ALIEN/Kernels/MCG/DataStructure/MCGMatrix.h>
#include <ALIEN/Kernels/MCG/DataStructure/MCGInternal.h>
#include <ALIEN/Kernels/MCG/LinearSolver/GPUOptionTypes.h>
#include <ALIEN/Kernels/MCG/LinearSolver/MCGInternalLinearSolver.h>
#include <ALIEN/Core/Backend/LinearSolverT.h>
#include <ALIEN/Core/Block/ComputeBlockOffsets.h>
#include <ALIEN/axl/GPUSolver_IOptions.h>
//Vector accessor?

/*---------------------------------------------------------------------------*/

#define MCGDEFSOLVERTYPE      0
#define MCGDEFPRECONDTYPE     "ilu0"
#define MCGDEFOUTPUTLEVEL     0
#define MCGDEFKEEPDIAG        0
#define MCGDEFNORMALIZEOPT    3 //without normalisation in MCGSolver
#define MCGDEFPOLYORDER       3
#define MCGDEFPOLYFACTOR      0.
#define MCGDEFRELAXFACTOR     0.
#define MCGDEFBSSORNUMITER    3
#define MCGDEFKERNEL          GPUOptionTypes::GPUKernel
#define MCGDEFREODEROPT       1
#define MCGDEFINTERFACEOPT    1
#define MCGDEFCXRSOLVER       1
#define MCGDEFRELAXSOLVER     1
#define MCGDEFAMGALGO         "PMIS"
#define MCGDEFILUCOLALG       "greeddir"
#define MCGDEFILUCOLDIR       "+Z"

namespace Alien {

/*---------------------------------------------------------------------------*/
MCGInternalLinearSolver::MCGInternalLinearSolver(
    IParallelMng* parallel_mng, IOptionsGPUSolver* options)
: m_gpu_solver(NULL)
, m_parallel_mng(parallel_mng)
, m_options(options)
{
  m_use_mpi = false;
  m_parallel_context = NULL;
  m_precond_opt = GPUOptionTypes::ILU0PC;

  m_solve_num = 0;
  m_current_solve_time = 0.;
  m_total_solve_time = 0.;
  m_current_system_time = 0.;
  m_total_system_time = 0.;
  m_total_iter_num = 0;
  m_int_total_solve_time = 0;
  m_int_total_setup_time = 0;
  m_int_total_finish_time = 0;

  m_max_iteration = 10000;
  m_precision = 1e-6;

  m_dir_enum[std::string("+Z")]=*((int *)"+Z-Z");
  m_dir_enum[std::string("-Z")]=*((int *)"-Z+Z");
  m_dir_enum[std::string("+X")]=*((int *)"+X-X");
  m_dir_enum[std::string("-X")]=*((int *)"-X+X");
  m_dir_enum[std::string("+Y")]=*((int *)"+Y-Y");
  m_dir_enum[std::string("-Y")]=*((int *)"-Y+Y");
  m_dir_enum[std::string("+D")]=*((int *)"+D-D");
  m_dir_enum[std::string("-D")]=*((int *)"-D+D");

  m_use_unit_diag = false ;
  m_keep_diag_opt = false;
  m_normalize_opt = 0 ;

  m_use_thread = false ;
  m_num_thread = 1;

  m_current_ctx_id = 0;

  m_output_level = 0 ;

}

/*---------------------------------------------------------------------------*/



MCGInternalLinearSolver::
~MCGInternalLinearSolver()
{
  delete m_parallel_context ;
  delete m_gpu_solver ;
}
/*---------------------------------------------------------------------------*/

//ToDo: à enlever
#if 0
void
MCGInternalLinearSolver::init(int argc, char const** argv)
{
  if(!m_gpu_solver)
    m_gpu_solver = new GPUSolver() ;
  //ToDo à retirer
  //m_gpu_solver->initParameter(argc,argv) ;
}
#endif

std::shared_ptr<Alien::ILinearAlgebra>
MCGInternalLinearSolver::algebra() const
{
  return std::shared_ptr<Alien::ILinearAlgebra>(new Alien::MCGLinearAlgebra());
}
/*---------------------------------------------------------------------------*/

void
MCGInternalLinearSolver::init()
{
	  m_output_level = m_options->output() ;
	  //m_use_unit_diag = m_options->useUnitDiag() ;
	  m_use_unit_diag = false;
	  m_keep_diag_opt = m_options->keepDiagOpt() ;
	  m_normalize_opt = m_options->normalizeOpt() ;
	  //if(m_use_unit_diag)
	  //  m_normalize_opt = true ;

	  m_use_mpi = m_parallel_mng->isParallel() ;
	  m_machine_info.init(m_parallel_mng->commRank()==0) ;

     
      if(m_use_mpi)
	  {
	    MPI_Comm comm = *static_cast<MPI_Comm*>(m_parallel_mng->getMPICommunicator());
        m_mpi_info->init(comm,false);
        m_parallel_context = new MCGSolver::ParallelContext<MCGSolver::PartitionInfo>(m_mpi_info,&m_machine_info) ;
	    //m_parallel_context->getMPIInfo()->init(comm, false) ; // external MPI management
	  }
	  m_use_thread = m_options->useThread();
	  m_num_thread = m_options->numThread();

	 // m_unit_test = m_options->unitTest() ;
	  m_matrix_file_name = m_options->matrixFileName() ;

	  m_max_iteration = m_options->maxIterationNum() ;
	  m_precision = m_options->stopCriteriaValue() ;
	  m_precond_opt = m_options->preconditioner() ;

	  m_solver_opt = m_options->solver() ;
	  //ConstArrayView<String> parameter = m_options->parameter() ;

	  //NB: possible leak!
	  m_gpu_solver = new GPUSolver() ;
	  m_gpu_solver->setMachineInfo(&m_machine_info) ;
	  if(m_use_mpi)
	    m_gpu_solver->initMPIInfo(m_mpi_info) ;


	  m_gpu_solver->setOpt(GPUSolver::SolverMaxIter,m_max_iteration) ;
	  m_gpu_solver->setOpt(GPUSolver::SolverEps,m_precision) ;
	  m_gpu_solver->setOpt(GPUSolver::UsePThread,m_use_thread) ;
	  m_gpu_solver->setOpt(GPUSolver::NumThread,m_num_thread) ;
	  m_gpu_solver->setOpt(GPUSolver::NormalizeOpt,m_normalize_opt) ;

	  if(m_options->exportOpt())
	  m_gpu_solver->setOpt(GPUSolver::DumpMatFileName, std::string(localstr(m_options->dumpMatFileName()))) ;

	  switch(m_solver_opt)
	  {
	  case GPUOptionTypes::BiCGStab:
	    m_gpu_solver->setOpt(GPUSolver::SolverType,GPUSolver::Solv::BiCGS) ;
	    break;
	  case GPUOptionTypes::Gmres:
	    m_gpu_solver->setOpt(GPUSolver::SolverType,GPUSolver::Solv::Gmres) ;
	    break ;
	  default :
	    ;
	  }
	  switch(m_precond_opt)
	  {
	    case GPUOptionTypes::PolyPC :
	      m_gpu_solver->setOpt(GPUSolver::PrecondOpt,GPUSolver::Precond::Poly) ;
	      m_gpu_solver->setOpt(GPUSolver::PolyOrder,m_options->polyOrder()) ;
	      m_gpu_solver->setOpt(GPUSolver::PolyFactor,m_options->polyFactor()) ;
	      break ;
	    case GPUOptionTypes::BSSORPC :
	      m_gpu_solver->setOpt((Integer)GPUSolver::PrecondOpt,(Integer)GPUSolver::Precond::BSSOR) ;
	      m_gpu_solver->setOpt((Integer)GPUSolver::BSSORRelaxFactor,(Real)m_options->bssorRelaxFactor()) ;
	      m_gpu_solver->setOpt((Integer)GPUSolver::BSSORNumIter,(Integer)m_options->bssorNumIter()) ;
	      break ;
	    case GPUOptionTypes::ILU0PC :
	      m_gpu_solver->setOpt((Integer)GPUSolver::PrecondOpt,(Integer)GPUSolver::Precond::ILU0) ;
	      break ;
	    case GPUOptionTypes::ColorBlockILU0PC :
	      m_dir = std::string(localstr(m_options->colorilu0Dir())) ;
	      m_gpu_solver->setOpt((Integer)GPUSolver::PrecondOpt,(Integer)GPUSolver::Precond::ColorBlockILU0) ;
        m_gpu_solver->setOpt(GPUSolver::CBILU0ColorMethod,std::string(localstr(m_options->colorilu0Algo())));
        m_gpu_solver->setOpt(GPUSolver::CBILU0Dir,((short *)&(m_dir_enum[m_dir]))[0]);
        m_gpu_solver->setOpt(GPUSolver::CBILU0OpDir,((short *)&(m_dir_enum[m_dir]))[1]);
	      break ;
	    case GPUOptionTypes::CprPC :
	      m_gpu_solver->setOpt((Integer)GPUSolver::PrecondOpt,(Integer)GPUSolver::Precond::Cpr) ;
	      m_gpu_solver->setOpt((Integer)GPUSolver::ReorderOpt,m_options->reorderOpt()?1:0) ;
	      m_gpu_solver->setOpt((Integer)GPUSolver::InterfaceOpt,m_options->interfaceOpt()) ;
	      m_gpu_solver->setOpt((Integer)GPUSolver::CxrSolver,m_options->cprSolver()) ;
	      m_gpu_solver->setOpt((Integer)GPUSolver::RelaxSolver,m_options->relaxSolver()) ;
	      m_gpu_solver->setOpt(GPUSolver::AmgAlgo, std::string(localstr(m_options->amgAlgo())));
	      break ;
	    case GPUOptionTypes::NonePC :
	      m_gpu_solver->setOpt((Integer)GPUSolver::PrecondOpt,(Integer)GPUSolver::Precond::None) ;
	      break ;
	    default :
	      ;
	  }

	  switch(m_options->kernel())
	  {
	    case GPUOptionTypes::CPUKernel:
	      if(m_use_mpi)
	        m_gpu_solver->init(GPUSolver::MPI_CPUCBLASKernel) ;
	      else
	        m_gpu_solver->init(GPUSolver::CPUCBLASKernel) ;
	      break ;
	    case GPUOptionTypes::CPUCBLASKernel:
	      if(m_use_mpi)
	        m_gpu_solver->init(GPUSolver::MPI_CPUCBLASKernel) ;
	      else
	        m_gpu_solver->init(GPUSolver::CPUCBLASKernel) ;
	      break;
	    case GPUOptionTypes::CPUAVXKernel:
	      m_gpu_solver->init(GPUSolver::CPUAVXKernel) ;
	      break;
	    case GPUOptionTypes::GPUCUBLASEllSpmvKernel:
	      m_gpu_solver->init(GPUSolver::GPUCUBLASEllSpmvKernel) ;
	      break;
	    case GPUOptionTypes::GPUCUBLASBSRSpmvKernel:
	      if(m_use_mpi)
	        m_gpu_solver->init(GPUSolver::MPI_GPUCUBLASBSRSpmvKernel) ;
	      else
	        m_gpu_solver->init(GPUSolver::GPUCUBLASBSRSpmvKernel) ;
	      break;
	    case GPUOptionTypes::GPUCUBLASBELLSpmvKernel:
	      if(m_use_mpi)
	        m_gpu_solver->init(GPUSolver::MPI_GPUCUBLASBELLSpmvKernel) ;
	      else
	        m_gpu_solver->init(GPUSolver::GPUCUBLASBELLSpmvKernel) ;
	      break;
	    case GPUOptionTypes::GPUCUBLASBCSPSpmvKernel:
	      if(m_use_mpi)
	        m_gpu_solver->init(GPUSolver::MPI_GPUCUBLASBCSPSpmvKernel) ;
	      else
	        m_gpu_solver->init(GPUSolver::GPUCUBLASBCSPSpmvKernel) ;
	      break;
	    case GPUOptionTypes::CPUSSE2Kernel:
	      alien_fatal([&] {
	        cout() << "CPUSSE2Kernel not supported anymore, use CPUCBLASKernel or CPUAVXKernel instead";});
	      break;
	    case GPUOptionTypes::GPUCUBLASIFPENV2SpmvKernel:
	      alien_fatal([&] {
          cout() << "GPUCUBLASIFPENV2SpmvKernel not supported anymore, use GPUCUBLASBELLSpmvKernel instead";});

	      break;
	    case GPUOptionTypes::GPUCUBLASIFPENV3SpmvKernel:
	      alien_fatal([&] {
          cout() << "GPUCUBLASIFPENV3SpmvKernel not supported anymore, use GPUCUBLASBCSPSpmvKernel instead";});
	    default :
	      m_gpu_solver->init() ;
	  }
          //vérifier la nécessité de context
	  m_current_ctx_id = m_gpu_solver->createNewContext() ;
}

void
MCGInternalLinearSolver::updateParallelMng(IParallelMng* pm)
{
  m_parallel_mng = pm;
}

/*---------------------------------------------------------------------------*/

void
MCGInternalLinearSolver::end()
{
}


bool MCGInternalLinearSolver::_solve(MCGMatrixType const& A, MCGVectorType const& b, MCGVectorType& x)
{
  if(m_output_level>0)
    alien_info([&] { cout()<<"MCGInternalLinearSolver::_solve"; });

  Integer error = -1 ;
  _startPerfCount();
  GPUSolver::System* system = NULL ;

  system = _computeGPUSystem(A,b,x,A.m_equations_num) ;
  error = m_gpu_solver->solve(system,&m_mcgs_status) ;
  delete system ;
  m_status.residual = m_mcgs_status.residual ;
  m_status.iteration_count = m_mcgs_status.num_iter ;

  _endPerfCount();

  if(error==0)
  {
    m_status.succeeded = true ;
    m_status.error = 0 ;
    if(m_output_level>0)
    {
      alien_info([&] {
	      cout()<<"Resolution info      :";
	      cout()<<"Resolution status      : OK";
	      cout()<<"Residual             : "<<m_mcgs_status.residual ;
	      cout()<<"Number of iterations : "<<m_mcgs_status.num_iter ;
	    });
    }
    return true ;
  }
  else
  {
    m_status.succeeded = false ;
    m_status.error = m_mcgs_status.error ;
    if(m_output_level>0)
    {
      alien_info([&] {
	      cout()<<"Resolution status      : Error";
	      cout()<<"Error code             : "<<m_mcgs_status.error ;
	    });
    }
    return false ;
  }
}


bool MCGInternalLinearSolver::_solve(MCGMatrixType const& A, MCGVectorType const& b, MCGVectorType& x, MCGVectorType& x0)
{
  if(m_output_level>0)
    alien_info([&] { cout()<<"MCGInternalLinearSolver::_solve"; });

  Integer error = -1 ;
  _startPerfCount();
  GPUSolver::System* system = NULL ;

  system = _computeGPUSystem(A,b,x,x0,A.m_equations_num) ;
  error = m_gpu_solver->solve(system,&m_mcgs_status) ;
  delete system ;
  m_status.residual = m_mcgs_status.residual ;
  m_status.iteration_count = m_mcgs_status.num_iter ;

  _endPerfCount();

  if(error==0)
  {
    m_status.succeeded = true ;
    m_status.error = 0 ;
    if(m_output_level>0)
    {
      alien_info([&] {
        cout()<<"Resolution info      :";
        cout()<<"Resolution status      : OK";
        cout()<<"Residual             : "<<m_mcgs_status.residual ;
        cout()<<"Number of iterations : "<<m_mcgs_status.num_iter ;
      });
    }
    return true ;
  }
  else
  {
    m_status.succeeded = false ;
    m_status.error = m_mcgs_status.error ;
    if(m_output_level>0)
    {
      alien_info([&] {
        cout()<<"Resolution status      : Error";
        cout()<<"Error code             : "<<m_mcgs_status.error ;
      });
    }
    return false ;
  }
}


bool MCGInternalLinearSolver::_solve(MCGMatrixType const& A,MCGVectorType const& diag_scal,MCGVectorType const& b, MCGVectorType& x)
{
  if(m_output_level>0)
    alien_info([&] { cout()<<"MCGInternalLinearSolver::_solve"; });

  Integer error = -1 ;
  _startPerfCount();
  GPUSolver::System* system = NULL ;

  system = _computeGPUSystem(A,diag_scal,b,x,A.m_equations_num) ;
  error = m_gpu_solver->solve(system,&m_mcgs_status) ;
  delete system ;
  m_status.residual = m_mcgs_status.residual ;
  m_status.iteration_count = m_mcgs_status.num_iter ;

  _endPerfCount();

  if(error==0)
  {
    m_status.succeeded = true ;
    m_status.error = 0 ;
    if(m_output_level>0)
    {
      alien_info([&] {
        cout()<<"Resolution info      :";
        cout()<<"Resolution status      : OK";
        cout()<<"Residual             : "<<m_mcgs_status.residual ;
        cout()<<"Number of iterations : "<<m_mcgs_status.num_iter ;
      });
    }
    return true ;
  }
  else
  {
    m_status.succeeded = false ;
    m_status.error = m_mcgs_status.error ;
    if(m_output_level>0)
    {
      alien_info([&] {
        cout()<<"Resolution status      : Error";
        cout()<<"Error code             : "<<m_mcgs_status.error ;
      });
    }
    return false ;
  }
}

bool MCGInternalLinearSolver::_solve(MCGMatrixType const& A,MCGVectorType const& diag_scal,MCGVectorType const& b, MCGVectorType& x, MCGVectorType& x0)
{
  if(m_output_level>0)
    alien_info([&] { cout()<<"MCGInternalLinearSolver::_solve"; });

  Integer error = -1 ;
  _startPerfCount();
  GPUSolver::System* system = NULL ;

  system = _computeGPUSystem(A,diag_scal,b,x,x0,A.m_equations_num) ;
  error = m_gpu_solver->solve(system,&m_mcgs_status) ;
  delete system ;
  m_status.residual = m_mcgs_status.residual ;
  m_status.iteration_count = m_mcgs_status.num_iter ;

  _endPerfCount();

  if(error==0)
  {
    m_status.succeeded = true ;
    m_status.error = 0 ;
    if(m_output_level>0)
    {
      alien_info([&] {
        cout()<<"Resolution info      :";
        cout()<<"Resolution status      : OK";
        cout()<<"Residual             : "<<m_mcgs_status.residual ;
        cout()<<"Number of iterations : "<<m_mcgs_status.num_iter ;
      });
    }
    return true ;
  }
  else
  {
    m_status.succeeded = false ;
    m_status.error = m_mcgs_status.error ;
    if(m_output_level>0)
    {
      alien_info([&] {
        cout()<<"Resolution status      : Error";
        cout()<<"Error code             : "<<m_mcgs_status.error ;
      });
    }
    return false ;
  }
}
#ifdef USE_HARTS
bool MCGInternalLinearSolver::_solveMC(CSRMatrixType const& A,
				       CSRVectorType const& b,
				       CSRVectorType& x)
{

  if(m_output_level>0)
    alien_info([&] { cout()<<"MCGLinearSolver::solve"; } ) ;

  _startPerfCount();

  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  //
  // GET CURRENT CONTEXT
  //
  GPUSolver::ContextType& context = m_gpu_solver->getContext(m_current_ctx_id) ;
  m_gpu_solver->setCurrentContext(&context) ;

  bool is_parallel = false ;
  IParallelMng* parallel_mng = A.distribution().parallelMng();
  if(parallel_mng)
    is_parallel = parallel_mng->isParallel() ;
  typedef MCGSolver::ParallelContext::MPIEnvType MPIEnvType ;
  MPIEnvType* mpi_env = NULL ;
  if(is_parallel)
  {
    mpi_env = context.get<MPIEnvType>(GPUSolver::Context::MPIEnv) ;
    if(mpi_env==NULL)
    {
      mpi_env = &m_parallel_context->getMPIInfo() ;
      context.set<MPIEnvType>(GPUSolver::Context::MPIEnv,mpi_env) ;
    }
  }
  ///////////////////////////////////////////////
  //
  // GET CURRENT PROFILE
  //

  typedef MCGSolver::CSRProfile             MCProfileType ;
  typedef MCGSolver::ProfileView            MCProfileViewType ;
  typedef MCProfileType::PermutationType    MCProfilePermType ;

  CSRMatrixType::ProfileType const& matrix_profile = A.internal().getCSRProfile() ;
  int nrows = matrix_profile.getNRow() ;
  int const* kcol = matrix_profile.getRowOffset().unguardedBasePointer() ;
  int const* cols = matrix_profile.getCols().unguardedBasePointer() ;


  typedef Graph::MPIPartition MPIPartitionType ;
  MPIPartitionType* partition_info = context.get<MPIPartitionType>(GPUSolver::Context::MPIPartition) ;
  if(is_parallel && partition_info==NULL)
  {
    Graph::MPIPartition* mpi_partition = new Graph::MPIPartition(mpi_env->getParallelMng()) ;
    mpi_partition->init(nrows) ;
    MCProfileViewType profile(kcol,cols,nrows) ;
    mpi_partition->compute(profile,true) ;
    partition_info = mpi_partition  ;
    context.set<MPIPartitionType>(GPUSolver::Context::MPIPartition,partition_info) ;
  }


  ////////////////////////////////////////////////////
  //
  // SOLVE
  //
  Integer error = 0 ;
  MCProfileType* profile = context.get<MCProfileType>(GPUSolver::Context::MatrixProfile) ;
  MCProfilePermType* profile_permutation = NULL ;
  if(profile==NULL)
  {
    if(partition_info)
    {
      profile_permutation = new MCProfilePermType(*partition_info) ;
      context.set<MCProfilePermType>(GPUSolver::Context::ProfilePermutation,profile_permutation) ;
    }
    if(profile_permutation)
    {
      profile = new MCProfileType() ;
      profile->init(nrows,kcol,cols,*profile_permutation) ;
    }
    else
      profile = new MCProfileType(nrows,kcol,cols) ;
    context.set<MCProfileType>(GPUSolver::Context::MatrixProfile,profile) ;
  }
  //int block_size =  A.space().structInfo().size() ;
  int block_size = A.block()->size() ;
  switch(block_size)
  {
  case 1:
    {
      typedef MCGSolver::CSRMatrix<Real,1>      MCMatrixType ;
      MCMatrixType matrix(profile) ;
      matrix.setValues(A.internal().getDataPtr(),profile_permutation) ;
      //matrix.updateValues(nrows,kcol,block_size,A.internal().getDataPtr()) ;
      if(is_parallel)
        error = m_gpu_solver->solve<1,true>(matrix,b.getDataPtr(),x.getDataPtr(),m_mcgs_status,context) ;
      else
        error = m_gpu_solver->solve<1,false>(matrix,b.getDataPtr(),x.getDataPtr(),m_mcgs_status,context) ;
    }
    break ;
  case 2:
    {
      typedef MCGSolver::CSRMatrix<Real,2>      MCMatrixType ;
      typedef MCMatrixType::MatrixDataType      MatrixDataType ;
      typedef MCMatrixType::VectorDataType      VectorDataType ;
      MCMatrixType matrix(profile) ;
      matrix.setValues((MatrixDataType const*)(A.internal().getDataPtr()),profile_permutation) ;
      //matrix.updateValues(nrows,kcol,block_size,A.internal().getDataPtr()) ;
      if(is_parallel)
        error = m_gpu_solver->solve<2,true>(matrix,
                                            reinterpret_cast<VectorDataType const*>(b.getDataPtr()),
                                            reinterpret_cast<VectorDataType*>(x.getDataPtr()),
                                            m_mcgs_status,context) ;
      else
        error = m_gpu_solver->solve<2,false>(matrix,
					     reinterpret_cast<VectorDataType const*>(b.getDataPtr()),
					     reinterpret_cast<VectorDataType*>(x.getDataPtr()),
					     m_mcgs_status,context) ;
    }
    break ;
  case 3:
    {
      typedef MCGSolver::CSRMatrix<Real,3>      MCMatrixType ;
      typedef MCMatrixType::MatrixDataType      MatrixDataType ;
      typedef MCMatrixType::VectorDataType      VectorDataType ;
      MCMatrixType matrix(profile) ;
      matrix.setValues((MatrixDataType const*)(A.internal().getDataPtr()),profile_permutation) ;
      //matrix.updateValues(nrows,kcol,block_size,A.internal().getDataPtr()) ;
      if(is_parallel)
	error = m_gpu_solver->solve<3,true>(matrix,
					    reinterpret_cast<VectorDataType const*>(b.getDataPtr()),
					    reinterpret_cast<VectorDataType*>(x.getDataPtr()),
					    m_mcgs_status,context) ;
      else
        error = m_gpu_solver->solve<3,false>(matrix,
					     reinterpret_cast<VectorDataType const*>(b.getDataPtr()),
					     reinterpret_cast<VectorDataType*>(x.getDataPtr()),
					     m_mcgs_status,context) ;
    }
    break ;
  case 4:
    {
      typedef MCGSolver::CSRMatrix<Real,4>      MCMatrixType ;
      typedef MCMatrixType::MatrixDataType      MatrixDataType ;
      typedef MCMatrixType::VectorDataType      VectorDataType ;
      MCMatrixType matrix(profile) ;
      matrix.setValues((MatrixDataType const*)(A.internal().getDataPtr()),profile_permutation) ;
      //matrix.updateValues(nrows,kcol,block_size,A.internal().getDataPtr()) ;
      if(is_parallel)
        error = m_gpu_solver->solve<4,true>(matrix,
                                            reinterpret_cast<VectorDataType const*>(b.getDataPtr()),
                                            reinterpret_cast<VectorDataType*>(x.getDataPtr()),
                                            m_mcgs_status,context) ;
      else
        error = m_gpu_solver->solve<4,false>(matrix,
					     reinterpret_cast<VectorDataType const*>(b.getDataPtr()),
					     reinterpret_cast<VectorDataType*>(x.getDataPtr()),
					     m_mcgs_status,context) ;
    }
    break ;
  default :
    break ;
  }

  _endPerfCount();

  ////////////////////////////////////////////////////
  //
  // ANALIZE STATUS
  m_status.residual = m_mcgs_status.residual ;
  m_status.iteration_count = m_mcgs_status.num_iter ;

  if(error==0)
  {
    m_status.succeeded = true ;
    m_status.error = 0 ;
    if(m_output_level>0)
    {
      alien_info([&] {
        cout()<<"Resolution info      :";
        cout()<<"Resolution status      : OK";
        cout()<<"Residual             : "<<m_mcgs_status.residual ;
        cout()<<"Number of iterations : "<<m_mcgs_status.num_iter ;
      }) ;
    }
    return true ;
  }
  else
  {
    m_status.succeeded = false ;
    m_status.error = m_mcgs_status.error ;
    if(m_output_level>0)
    {
      alien_info([&] {
        cout()<<"Resolution status      : Error";
        cout()<<"Error code             : "<<m_mcgs_status.error ;
      }) ;
    }
    return false ;
  }
}

bool MCGInternalLinearSolver::_solve(CSRMatrixType const& A, CSRVectorType const& b, CSRVectorType& x)
{
  typedef MCGSolver::CSRMatrix<Real> MCMatrixType ;
  typedef MCMatrixType::ProfileType       MCProfileType ;

  if(m_output_level>0)
    alien_info([&] { cout()<<"MCGInternalLinearSolver::solve"; });

  _startPerfCount();

  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
  //
  // GET CURRENT CONTEXT
  //
  GPUSolver::ContextType& context = m_gpu_solver->getContext(m_current_ctx_id) ;
  m_gpu_solver->setCurrentContext(&context) ;

  ///////////////////////////////////////////////
  //
  // GET CURRENT PROFILE
  //
  MCProfileType* profile = context.get<MCProfileType>(GPUSolver::Context::MatrixProfile) ;
  int block_size =  A.block()->size() ;
  CSRMatrixType::ProfileType const& matrix_profile = A.internal().getCSRProfile() ;
  int nrows = matrix_profile.getNRow() ;
  int const* kcol = matrix_profile.getRowOffset().unguardedBasePointer() ;
  int const* cols = matrix_profile.getCols().unguardedBasePointer() ;
  if(profile==NULL)
  {
    profile = new MCProfileType(nrows,kcol,cols,block_size) ;
    context.set<MCProfileType>(GPUSolver::Context::MatrixProfile,profile) ;
  }
  ////////////////////////////////////////////////////
  //
  // SOLVE
  //
  MCMatrixType matrix(profile) ;
  matrix.setValues((Real*)A.internal().getDataPtr()) ;

  Integer error = m_gpu_solver->solve<1,false>(matrix,b.getDataPtr(),x.getDataPtr(),m_mcgs_status,context) ;

  _endPerfCount();

  ////////////////////////////////////////////////////
  //
  // ANALIZE STATUS
  m_status.residual = m_mcgs_status.residual ;
  m_status.iteration_count = m_mcgs_status.num_iter ;

  if(error==0)
  {
    m_status.succeeded = true ;
    m_status.error = 0 ;
    if(m_output_level>0)
    {
      alien_info([&] {
	  cout()<<"Resolution info      :";
	  cout()<<"Resolution status      : OK";
	  cout()<<"Residual             : "<<m_mcgs_status.residual ;
	  cout()<<"Number of iterations : "<<m_mcgs_status.num_iter ;
	});
    }
    return true ;
  }
  else
  {
    m_status.succeeded = false ;
    m_status.error = m_mcgs_status.error ;
    if(m_output_level>0)
    {
      alien_info([&] {
	  cout()<<"Resolution status      : Error";
	  cout()<<"Error code             : "<<m_mcgs_status.error ;
	});
    }
    return false ;
  }
}
#endif

template<int N>
GPUSolver::System*
MCGInternalLinearSolver::_createSystem(MCGMatrixType const& A, MCGVectorType const& b, MCGVectorType& x)
{
  typedef typename MCGInternal::CSRStruct<N>::MatrixBN MatrixBN ;
  MCGInternal::CSRStruct<N> const& csr = A.template getCSRStruct<N>() ;
  if(A.m_cmatrix==NULL)
  {
    GPUSolver::System* system = GPUSolver::System::create<N>(const_cast<MatrixBN*>(csr.m_matrix),
                                                             (GPUInternal::Vector*)&b.m_internal,
                                                              &x.m_internal,
                                                              m_use_unit_diag,
                                                              NULL,
                                                              m_parallel_context) ;
    return system ;
  }
  else
  {
    GPUSolver::System* system = GPUSolver::System::create<N>(const_cast<MatrixBN*>(csr.m_matrix),
                                                             A.m_cmatrix,
                                                             csr.m_cmatrix2matrix,
                                                             csr.m_matrix2cmatrix,
                                                             (GPUInternal::Vector*)&b.m_internal,
                                                             (GPUInternal::Vector*)&b.m_extra_eq_internal,
                                                             &x.m_internal,
                                                             &x.m_extra_eq_internal,
                                                             m_use_unit_diag,
                                                             NULL,
                                                             m_parallel_context) ;
    m_gpu_solver->setOpt(GPUSolver::TestUseWell,true);
    return system ;
  }
}

template<int N>
GPUSolver::System*
MCGInternalLinearSolver::_createSystem(MCGMatrixType const& A, MCGVectorType const& b, MCGVectorType& x, MCGVectorType& x0)
{
  typedef typename MCGInternal::CSRStruct<N>::MatrixBN MatrixBN ;
  MCGInternal::CSRStruct<N> const& csr = A.template getCSRStruct<N>() ;
  if(A.m_cmatrix==NULL)
  {
    GPUSolver::System* system = GPUSolver::System::create<N>(const_cast<MatrixBN*>(csr.m_matrix),
                                                             (GPUInternal::Vector*)&b.m_internal,
                                                              &x.m_internal,
                                                              &x0.m_internal,
                                                              NULL,
                                                              m_parallel_context) ;
    return system ;
  }
  else
  {
    GPUSolver::System* system = GPUSolver::System::create<N>(const_cast<MatrixBN*>(csr.m_matrix),
                                                              A.m_cmatrix,
                                                              csr.m_cmatrix2matrix,
                                                              csr.m_matrix2cmatrix,
                                                             (GPUInternal::Vector*)&b.m_internal,
                                                             (GPUInternal::Vector*)&b.m_extra_eq_internal,
                                                              &x.m_internal,
                                                              &x.m_extra_eq_internal,
                                                              &x0.m_internal,
                                                              &x0.m_extra_eq_internal,
                                                              NULL,
                                                              m_parallel_context) ;
    m_gpu_solver->setOpt(GPUSolver::TestUseWell,true);
    return system ;
  }
}

template<int N>
GPUSolver::System*
MCGInternalLinearSolver::_createSystem(MCGMatrixType const& A,MCGVectorType const& diag_scal,
    MCGVectorType const& b, MCGVectorType& x)
{
  typedef typename MCGInternal::CSRStruct<N>::MatrixBN MatrixBN ;
  MCGInternal::CSRStruct<N> const& csr = A.template getCSRStruct<N>() ;
  if(A.m_cmatrix==NULL)
  {
    GPUSolver::System* system = GPUSolver::System::create<N>(const_cast<MatrixBN*>(csr.m_matrix),
                                                             (GPUInternal::Vector*)&b.m_internal,
                                                             &x.m_internal,
                                                             (GPUInternal::Vector*)&diag_scal.m_internal,
                                                             m_use_unit_diag,
                                                             NULL,
                                                             m_parallel_context) ;
    return system ;
  }
  else
  {
    GPUSolver::System* system = GPUSolver::System::create<N>(const_cast<MatrixBN*>(csr.m_matrix),
                                                              A.m_cmatrix,
                                                              csr.m_cmatrix2matrix,
                                                              csr.m_matrix2cmatrix,
                                                             (GPUInternal::Vector*)&b.m_internal,
                                                             (GPUInternal::Vector*)&b.m_extra_eq_internal,
                                                              &x.m_internal,
                                                              &x.m_extra_eq_internal,
                                                              (GPUInternal::Vector*)&diag_scal.m_internal,
                                                              m_use_unit_diag,
                                                              NULL,
                                                              m_parallel_context) ;
    m_gpu_solver->setOpt(GPUSolver::TestUseWell,true);
    return system ;
  }
}

template<int N>
GPUSolver::System*
MCGInternalLinearSolver::_createSystem(MCGMatrixType const& A,MCGVectorType const& diag_scal,
                               MCGVectorType const& b, MCGVectorType& x, MCGVectorType& x0)
{
  typedef typename MCGInternal::CSRStruct<N>::MatrixBN MatrixBN ;
  MCGInternal::CSRStruct<N> const& csr = A.template getCSRStruct<N>() ;
  if(A.m_cmatrix==NULL)
  {
    GPUSolver::System* system = GPUSolver::System::create<N>(const_cast<MatrixBN*>(csr.m_matrix),
                                                             (GPUInternal::Vector*)&b.m_internal,
                                                             &x.m_internal,
                                                             &x0.m_internal,
                                                             (GPUInternal::Vector*)&diag_scal.m_internal,
                                                             NULL,
                                                             m_parallel_context) ;
    return system ;
  }
  else
  {
    GPUSolver::System* system = GPUSolver::System::create<N>(const_cast<MatrixBN*>(csr.m_matrix),
                                                              A.m_cmatrix,
                                                              csr.m_cmatrix2matrix,
                                                              csr.m_matrix2cmatrix,
                                                             (GPUInternal::Vector*)&b.m_internal,
                                                             (GPUInternal::Vector*)&b.m_extra_eq_internal,
                                                              &x.m_internal,
                                                              &x.m_extra_eq_internal,
                                                              &x0.m_internal,
                                                              &x0.m_extra_eq_internal,
                                                              (GPUInternal::Vector*)&diag_scal.m_internal,
                                                              NULL,
                                                              m_parallel_context) ;
    m_gpu_solver->setOpt(GPUSolver::TestUseWell,true);
    return system ;
  }
}

GPUSolver::System*
MCGInternalLinearSolver::_computeGPUSystem(MCGMatrixType const& A, MCGVectorType const& b, MCGVectorType& x,Integer equations_num)
{
  switch(equations_num)
  {
  case 1 :
    return _createSystem<1>(A,b,x) ;
  case 2 :
    return _createSystem<2>(A,b,x) ;
  case 3 :
    return _createSystem<3>(A,b,x) ;
  case 4 :
    return _createSystem<4>(A,b,x) ;
  }
  return NULL ;
}

GPUSolver::System*
MCGInternalLinearSolver::_computeGPUSystem(MCGMatrixType const& A, MCGVectorType const& b, MCGVectorType& x, MCGVectorType& x0,Integer equations_num)
{
  switch(equations_num)
  {
    case 1 :
      return _createSystem<1>(A,b,x,x0) ;
    case 2 :
      return _createSystem<2>(A,b,x,x0) ;
    case 3 :
      return _createSystem<3>(A,b,x,x0) ;
    case 4 :
      return _createSystem<4>(A,b,x,x0) ;
  }
  return NULL ;
}

GPUSolver::System*
MCGInternalLinearSolver::_computeGPUSystem(MCGMatrixType const& A, MCGVectorType const& diag_scal,
                                   MCGVectorType const& b, MCGVectorType& x,Integer equations_num)
{
  switch(equations_num)
  {
    case 1 :
      return _createSystem<1>(A,diag_scal,b,x) ;
    case 2 :
      return _createSystem<2>(A,diag_scal,b,x) ;
    case 3 :
      return _createSystem<3>(A,diag_scal,b,x) ;
    case 4 :
      return _createSystem<4>(A,diag_scal,b,x) ;
  }
  return NULL ;
}

GPUSolver::System*
MCGInternalLinearSolver::_computeGPUSystem(MCGMatrixType const& A, MCGVectorType const& diag_scal,
                                   MCGVectorType const& b, MCGVectorType& x, MCGVectorType& x0,Integer equations_num)
{
  switch(equations_num)
  {
    case 1 :
      return _createSystem<1>(A,diag_scal,b,x,x0) ;
    case 2 :
      return _createSystem<2>(A,diag_scal,b,x,x0) ;
    case 3 :
      return _createSystem<3>(A,diag_scal,b,x,x0) ;
    case 4 :
      return _createSystem<4>(A,diag_scal,b,x,x0) ;
  }
  return NULL ;
}
void
MCGInternalLinearSolver::
_startPerfCount()
{
}

/*---------------------------------------------------------------------------*/

void
MCGInternalLinearSolver::
_endPerfCount()
{
  m_solve_num++;
  m_total_iter_num += m_status.iteration_count;

  m_int_total_solve_time += m_mcgs_status.solve_time;
  m_int_total_setup_time += m_mcgs_status.setup_time;
  m_int_total_finish_time += m_mcgs_status.finish_time;
}


const Alien::SolverStatus&
MCGInternalLinearSolver::
getStatus() const
{
  if(m_output_level>0)
  {
    printInfo();
  }
  return m_status;
}

void
MCGInternalLinearSolver::
printInfo()
{
  alien_info([&] {
      cout();
      cout()<<"|--------------------------------------------|";
      cout()<<"| Linear Solver        : MCGSolver           |";
      cout()<<"|--------------------------------------------|";
      cout()<<"| total solver time    : "<<m_total_solve_time;
      cout()<<"| total system time    : "<<m_total_system_time;
      cout()<<"| total num of iter    : "<<m_total_iter_num;
      cout()<<"| solve num            : "<<m_solve_num;
      cout()<<"| internal setup time  : "<<m_int_total_setup_time;
      cout()<<"| internal solve time  : "<<m_int_total_solve_time;
      cout()<<"| internal finish time : "<<m_int_total_finish_time;
      cout()<<"|---------------------------------------------|";
      cout();
    });
}

void
MCGInternalLinearSolver::
printInfo() const
{
  alien_info([&] {
      cout();
      cout()<<"|--------------------------------------------|";
      cout()<<"| Linear Solver        : MCGSolver           |";
      cout()<<"|--------------------------------------------|";
      cout()<<"| total solver time    : "<<m_total_solve_time;
      cout()<<"| total system time    : "<<m_total_system_time;
      cout()<<"| total num of iter    : "<<m_total_iter_num;
      cout()<<"| solve num            : "<<m_solve_num;
      cout()<<"| internal setup time  : "<<m_int_total_setup_time;
      cout()<<"| internal solve time  : "<<m_int_total_solve_time;
      cout()<<"| internal finish time : "<<m_int_total_finish_time;
      cout()<<"|---------------------------------------------|";
      cout();
    });
}


bool
MCGInternalLinearSolver::
solve(IMatrix const& A, IVector const& b, IVector& x)
{
  using namespace Alien;
  using namespace Alien::MCGInternal;


#ifdef USE_HARTS
  if(m_options->kernel()==GPUOptionTypes::MCKernel)
  {
    m_stater.startPrepareMeasure();
    CSRMatrixType const& matrix = A.impl()->get<BackEnd::tag::simplecsr>() ;
    CSRVectorType const& rhs = b.impl()->get<BackEnd::tag::simplecsr>() ;
    CSRVectorType& sol = x.impl()->get<BackEnd::tag::simplecsr>(true) ;
    m_stater.stopPrepareMeasure();

    return _solveMC(matrix,rhs,sol) ;
  }
  else
#endif
  {
    m_stater.startPrepareMeasure();
    if(A.impl()->hasFeature("composite"))
    {
      MCGMatrix const& matrix = A.impl()->get<BackEnd::tag::mcgsolver>() ;
      MCGVector const& rhs = b.impl()->get<BackEnd::tag::mcgsolver>() ;
      MCGVector& sol = x.impl()->get<BackEnd::tag::mcgsolver>(true) ;

      //comment recuperer une partie de la matrice composite...
      //int matrice00_blocksize = matrix(0,0).size();

      if(m_use_mpi)
      {
        ConstArrayView<int> offsets;
        ConstArrayView<int> woffsets;
        UniqueArray<Integer> blockOffsets;
        //Why block size is duplicated
        int block_size;
        Integer nproc = m_parallel_mng->commSize() ;
        if(A.impl()->block())
        {
          computeBlockOffsets(matrix.distribution(), *A.impl()->block(), blockOffsets);
          int blockSize =  A.impl()->block()->size();
#ifdef ALIEN_USE_ARCANE
            offsets = blockOffsets.constView();
#else
            offsets = ConstArrayView<int>(blockOffsets);
#endif
            block_size = blockSize;
        }
        else
        {
          Integer loffset = matrix.distribution().rowOffset();          
          UniqueArray<Integer> scalarOffsets;

          scalarOffsets.resize(nproc+1);
          m_parallel_mng->allGather(ConstArrayView<int>(1,&loffset),
          ArrayView<int>(nproc,dataPtr(scalarOffsets)));
          scalarOffsets[nproc] = matrix.distribution().globalRowSize();
#ifdef ALIEN_USE_ARCANE
          offsets = scalarOffsets.constView();
#else
            offsets = ConstArrayView<int>(scalarOffsets);
#endif
          block_size = 1;
        }

         const int * offsets1_tmp = matrix.get_row_offset1();
         const int * offsets2_tmp = matrix.get_row_offset2();



        //m_parallel_context->getPartitionInfo().init((int*)dataPtr(offsets),offsets.size(),block_size) ;
         m_parallel_context->getPartitionInfo().init((int*)offsets1_tmp,(std::size_t)(nproc+1),block_size) ;
         
        // XT (24/03/2016) : there is something wrong here -> two different values of offsets are used in the former version. Need to understand what they represent.
        //m_parallel_context->getExtraPartitionInfo().init((int*)dataPtr(woffsets),woffsets.size()) ;
        m_parallel_context->getExtraPartitionInfo().init((int*)offsets2_tmp,(std::size_t)(nproc+1)) ;
        /*
        //ConstArrayView<int> offsets = matrix.space().structInfo().getOffsets() ;
        const Block* block
        ConstArrayView<int> offsets = A.impl()->block()->getOffsets();
        int block_size =  A.impl()->block()->size() ;
        m_parallel_context->getPartitionInfo().init((int*)dataPtr(offsets),offsets.size(),block_size) ;
        // COUPLED SYSTEM DISTRIBUTION
        //ConstArrayView<int> offsets1 = matrix.space1().structInfo().getOffsets() ;
        ConstArrayView<int> offsets1 = A.impl()->block()->getOffsets() ;
        m_parallel_context->getExtraPartitionInfo().init((int*)dataPtr(offsets1),offsets1.size()) ;
        */
      }
      m_stater.stopPrepareMeasure();

      return _solve(*matrix.internal(),*rhs.internal(),*sol.internal()) ;

    }
    else
    {
      MCGMatrix const& matrix = A.impl()->get<BackEnd::tag::mcgsolver>() ;
      MCGVector const& rhs = b.impl()->get<BackEnd::tag::mcgsolver>() ;
      MCGVector& sol = x.impl()->get<BackEnd::tag::mcgsolver>(true) ;

      if(m_use_mpi)
      {
	ConstArrayView<int> offsets;
	UniqueArray<Integer> blockOffsets;
	int block_size;
	if(A.impl()->block())
	{
	  computeBlockOffsets(matrix.distribution(), *A.impl()->block(), blockOffsets);
	  int blockSize =  A.impl()->block()->size();
#ifdef ALIEN_USE_ARCANE
    offsets = blockOffsets.constView();
#else
    offsets = ConstArrayView<int>(blockOffsets);
#endif
	  block_size = blockSize;
	}
	else
	{
	  Integer loffset = matrix.distribution().rowOffset();
	  Integer nproc = m_parallel_mng->commSize() ;
	  UniqueArray<Integer> scalarOffsets;
	  scalarOffsets.resize(nproc+1);
	  m_parallel_mng->allGather(ConstArrayView<int>(1,&loffset),
				    ArrayView<int>(nproc,dataPtr(scalarOffsets)));
	  scalarOffsets[nproc] = matrix.distribution().globalRowSize();
#ifdef ALIEN_USE_ARCANE
	  offsets = scalarOffsets.constView();
#else
    offsets = ConstArrayView<int>(scalarOffsets);
#endif
	  block_size = 1;
	}
	m_parallel_context->getPartitionInfo().init((int*)dataPtr(offsets),offsets.size(),block_size) ;
      }
      m_stater.stopPrepareMeasure();

      return _solve(*matrix.internal(),*rhs.internal(),*sol.internal()) ;
    }
  }
}

ILinearSolver*
MCGInternalLinearSolverFactory(IParallelMng* p_mng, IOptionsGPUSolver* options)
{
  return new MCGInternalLinearSolver(p_mng, options);
}

} // namespace Alien
