// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
#ifndef ARCANEDEMO_DTLOCAL_TOYREACTIVETRANSPORTCOUPLAGEDTLOCALMODULE_H
#define ARCANEDEMO_DTLOCAL_TOYREACTIVETRANSPORTCOUPLAGEDTLOCALMODULE_H
/* Author : willien at Tue Apr  1 14:50:50 2008
 * Generated by createNew
 */

#include "Numerics/DiscreteOperator/IDivKGradDiscreteOperator.h"

#include <arcane/ITimeLoopMng.h>
#include <arcane/IVariable.h>
#include <arcane/IVariableAccessor.h>
#include "ToyReactiveTransportCouplageDtLocal_axl.h"

using namespace Arcane;

class IOp ;
class IIntOp ;
class IDivKGradDiscreteOperator ;
template<typename SchemeType> class FluxModelT;
class ICouplingModelSolver ;

class ToyReactiveTransportCouplageDtLocalModule
: public ArcaneToyReactiveTransportCouplageDtLocalObject
{
 public:
   typedef ISubDomainModel::VarCellReal VarCellReal ;
   typedef ISubDomainModel::VarFaceReal VarFaceReal ;
   typedef FluxModelT<IDivKGradDiscreteOperator> DiffFluxModelType;
   typedef FluxModelT<IAdvectionOperator> AdvFluxModelType;

  /** Constructeur de la classe */
  ToyReactiveTransportCouplageDtLocalModule(const Arcane::ModuleBuildInfo& mbi)
    : ArcaneToyReactiveTransportCouplageDtLocalObject(mbi)
    , m_coarse_time_mng(NULL)
    , m_fine_time_mng(NULL)
    , m_time_step_mng(NULL)
    , m_time_integrator(NULL)
    , m_dom_global(NULL)
    , m_dom_reservoir(NULL)
    , m_dom_window(NULL)
    , m_overlap_diff_flux_scheme(NULL)
    , m_overlap_diff_flux_model(NULL)
    , m_overlap_adv_flux_scheme(NULL)
    , m_overlap_adv_flux_model(NULL)
    , m_global_collector(NULL)
    , m_reservoir_collector(NULL)
    , m_coarse_window_collector(NULL)
    , m_fine_window_collector(NULL)
    , m_solver(NULL)
    , m_u_concentration_fine(NULL)
    , m_v_concentration_fine(NULL)
    , m_u_concentration_fine_tn(NULL)
    , m_v_concentration_fine_tn(NULL)
    , m_u_concentration_coarse(NULL)
    , m_v_concentration_coarse(NULL)
    , m_u_concentration_coarse_tn(NULL)
    , m_v_concentration_coarse_tn(NULL)
    , m_overlap_domain(NULL)
    , m_w_bc_neumann(NULL)
    , m_w_bc_dirichlet(NULL)
    , m_r_bc_neumann(NULL)
    , m_r_bc_dirichlet(NULL)
    , m_first_iter(true)
    , m_first_solver_step(true)
    , m_teta(0)
    , m_error(0)
    , m_iteration(1)
  {

  }

  /** Destructeur de la classe */
  virtual ~ToyReactiveTransportCouplageDtLocalModule() ;

 public:
  virtual void init();

  virtual void compute();

  virtual void restore();

  /** Retourne le numéro de version du module */
  virtual Arcane::VersionInfo versionInfo() const { return Arcane::VersionInfo(1,0,0); }
  void computeDeltaT() ;

  void initFinePressure() ;
  void initCoarsePressure() ;
  void initPressureOnWindow();
  void initPressureOnReservoir();
  void computePressureOnOverlap();
  void computeWindowDirichletCellPressure() ;
  void computeReservoirDirichletCellPressure() ;
  void computeVFDirichletOverlapForWindow() ;
  void computeVFDirichletOverlapForReservoir() ;
  //void computeInterfacePressureForReservoir() ;
  //void computeInterfacePressureForWindow() ;
  Integer updateConvergenceOnReservoirOverlap();
  Integer updateConvergenceOnWindowOverlap();
  void updatePressureFromWindow() ;
  void updatePressureFromReservoir() ;
  void updatePressureTN() ;
  void initAverageFluxOnOverlap() ;
  void integrateFluxOnOverlap() ;
  void computeAverageFluxOnOverlap() ;
  void computeWindowPressureOnOverlap() ;
  void computeReservoirPressureOnOverlap() ;
  void initCoarsePressureOnOverlap() ;
  void updateCoarsePressureOnOverlap() ;

  Integer getError() {
    return m_error ;
  }

private :
  Integer m_output_level ;
  void initModelDomains() ;
  void setBoundaryCondition(ISubDomainModel* model,
                            Array<FaceGroup>& bc_groups) ;

  CellGroup m_window_group;
  CellGroup m_reservoir_group;
  CellGroup m_overlap_group;

  typedef enum {
    CoarseDtSeq, //! Coarse time step computation sequence
    FineDtSeq,   //! Fine time step computation sequence
  } eTimeStepSeqType ;

  typedef enum {
    BC0,
    BC1,
    BC2,
    BC3,
  } eBCLabel ;

  typedef enum {
    BOUNDARY0,
    BOUNDARY1
  } eBoundaryLabel ;

  Integer m_nb_appel;
  Real m_current_time ;
  Real m_current_time_step ;
  Real m_fine_dt;
  ITimeMng* m_coarse_time_mng ;
  ITimeMng* m_fine_time_mng ;
  ITimeStepMng* m_time_step_mng ;
  ITimeIntegrator* m_time_integrator ;

  INumericalModel *m_dom_global;
  INumericalModel *m_dom_reservoir;
  INumericalModel *m_dom_window;
  IDivKGradDiscreteOperator* m_overlap_diff_flux_scheme ;
  DiffFluxModelType* m_overlap_diff_flux_model ;
  IAdvectionOperator* m_overlap_adv_flux_scheme ;
  AdvFluxModelType* m_overlap_adv_flux_model ;

  
  ICollector* m_global_collector ;
  ICollector* m_reservoir_collector ;
  ICollector* m_coarse_window_collector ;
  ICollector* m_fine_window_collector ;

  ICouplingModelSolver* m_solver ;

 private:
  //!Global domain description
  CellGroup m_global_cell_group;
  FaceGroup m_global_face_group;
  NodeGroup m_global_node_group;
  FaceGroup m_global_internal_face;
  FaceGroup m_global_boundary_face;

  //!Window domain description
  //!@{
  FaceGroup m_window_internal_face;
  FaceGroup m_window_boundary_face;
  FaceGroup m_interface_face_group;

  //! window = fine region
  FaceGroup m_windowFaceGp;
  PartialVariableCellReal* m_u_concentration_fine ;
  PartialVariableCellReal* m_v_concentration_fine ;
  PartialVariableCellReal* m_u_concentration_fine_tn ;
  PartialVariableCellReal* m_v_concentration_fine_tn ;
  
  // maille qui contient une CL Dirichlet a imposer sur la zone window
  CellGroup m_cell_interfaceW_group;
  ItemGroupMapT<Face,Cell> m_w_interface_cells ;
  //!@}

  //!Reservoir domain description
  //!@{
  FaceGroup m_reservoir_internal_face;
  FaceGroup m_reservoir_boundary_face;
  PartialVariableCellReal* m_u_concentration_coarse ;
  PartialVariableCellReal* m_v_concentration_coarse ;
  PartialVariableCellReal* m_u_concentration_coarse_tn ;
  PartialVariableCellReal* m_v_concentration_coarse_tn ;
  // reservoir = coarse region
  FaceGroup m_reservoirFaceGp;
  // maille qui contient une CL Dirichlet a imposer sur la zone Reservoir
  CellGroup m_cell_interfaceR_group;
  ItemGroupMapT<Face,Cell> m_r_interface_cells ;
  //!@}

  //! overlap domain description
  //!@{
  //! faces of domain
  FaceGroup m_overlapFaceGp;
  //! face interieure de la zone overlap
  FaceGroup m_overlap_inner_group;
  //! face exterieure de la zone overlap
  FaceGroup m_overlap_border_group;
  //! overlap domain for flux model
  SubDomainModelProperty::NumericalDomain* m_overlap_domain ;

  ItemGroupMapT<Cell,Real> m_u_concentration_overlap ;
  ItemGroupMapT<Cell,Real> m_old_u_concentration_overlap ;
  ItemGroupMapT<Cell,Real> m_coarse_u_concentration_overlap ;
  ItemGroupMapT<Cell,Real> m_coarse_u_concentration_overlap_tn ;
  ItemGroupMapT<Cell,Real> m_v_concentration_overlap ;
  ItemGroupMapT<Cell,Real> m_old_v_concentration_overlap ;
  ItemGroupMapT<Cell,Real> m_coarse_v_concentration_overlap ;
  ItemGroupMapT<Cell,Real> m_coarse_v_concentration_overlap_tn ;

  //!flux of interface domain
  //!@{
  ItemGroupMapT<Face,Real> m_flux_overlap ;
  ItemGroupMapT<Face,Real> m_flux_ratio ;
  ItemGroupMapT<Face,Real> m_average_flux ;
  ItemGroupMapT<Face,Real> m_integral_flux ;
  Real m_integral_length;
  //!@}
  //!@}

  // reservoir + overlap
  CellGroup m_overlap_reservoirGp;
  FaceGroup m_overlap_reservoirFaceGp;

  Integer m_interface_id ;
  // bc groups
  Array<FaceGroup> m_bc_group_w ;
  Array<FaceGroup> m_bc_group_r ;
  Array<FaceGroup> m_bc_group_g ;

  Array<Real> m_val_limit1 ;
  Array<Real> m_val_limit2 ;
  ISubDomainModel::FaceBoundaryCondition* m_w_bc_neumann ;
  ISubDomainModel::FaceBoundaryCondition* m_w_bc_dirichlet ;
  ISubDomainModel::FaceBoundaryCondition* m_r_bc_neumann ;
  ISubDomainModel::FaceBoundaryCondition* m_r_bc_dirichlet ;
  bool m_first_iter ;
  bool m_first_solver_step ;
  Real m_teta ;

  Integer m_error ;
  
  IGeometryMng* m_geometry;

 private:
  Integer m_iteration;
  void writeoutput();
  void readGroup();
  void checkGroup();
  void setBoundaryCondition(ISubDomainModel* sd_model,
                            bool is_global_domain) ;
  void computeInitialState() ;
  TypesDtLocal::eComputationType m_computation_opt ;

  void computeGlobalDomainWithCoarseDt() ;
  void computeGlobalDomainWithFineDt() ;
  void computeDFVF1();
  void computeDFVF2();

  //Old version
  void computeVFVF1();
  void computeVFVF2();

  void computeFluxOnOverlap();

  void computeDirichletOverlapForReservoir();
  Integer updateConvergenceOnOverlap(const CellGroup& cell_group);
  void computeInterfaceFacePressure(const FaceGroup& group,
                                    const ItemGroupMapT<Cell,Real>& u_concentration,
                                    ItemGroupMapT<Face,Cell>& exterior_cells,
                                    ItemGroupMapT<Face,Real>& face_u_concentration) ;
  void computeReservoirInterfaceFacePressure() ;
  void computeWindowInterfaceFacePressure() ;
  void computeAveragePressureOnWindow(Real deltat);
  void computeAverageFluxOnOverlap(Real deltat);
  Integer updateVFConvergenceOnOverlap(const CellGroup& cell_group);
  void computeVFDirichletOverlapForWindow(Real current_time, Real dt_local, Array<Real> Val_Lim1, Array<Real> Val_Lim2 );

  //!copy of cell collections, warning group and collection should be compatible
  template<class Collection1, class Collection2>
  void _copy(const CellGroup& group,Collection1& pressure1,const Collection2& pressure2)
  {
    ENUMERATE_CELL(icell,group)
    {
      pressure1[icell] = pressure2[icell] ;
    }
  }
  //!safe copy of cell collection, group and collection can be not compatible
  template<class Collection1, class Collection2>
  void _copy2(const CellGroup& group,Collection1& pressure1,const Collection2& pressure2)
  {
    ENUMERATE_CELL(icell,group)
    {
      const Cell& cell = *icell ;
      pressure1[cell] = pressure2[cell] ;
    }
  }
  //!save and copy of cell collections, warning group and collection should be compatible
  template<class Collection1, class Collection2, class Collection3>
  void _copysave(const CellGroup& group,
                 Collection1& pressure1,
                 Collection2& pressure2,
                 const Collection3& pressure3)
  {
    ENUMERATE_CELL(icell,group)
    {
      pressure1[icell] = pressure2[icell] ;
      pressure2[icell] = pressure3[icell] ;
    }
  }
  //!safe save and copy of cell collections, group and collection can be not compatible
  template<class Collection1, class Collection2, class Collection3>
  void _copysave2(const CellGroup& group,
                 Collection1& pressure1,
                 Collection2& pressure2,
                 const Collection3& pressure3)
  {
    ENUMERATE_CELL(icell,group)
    {
      const Cell& cell = *icell ;
      pressure1[cell] = pressure2[cell] ;
      pressure2[cell] = pressure3[cell] ;
    }
  }
  void updateOverlapPressure() ;
  void computeDirichletCellPressure(Arcane::Array<Real>&, Arcane::Array<Real>&, const CellGroup&) ;
  void computeDirichletCellPressure(Arcane::Array<Real>&, Arcane::Array<Real>&,Real teta, const CellGroup&) ;

 public :
 class ReservoirInterfaceUpdater : public INumericalModel::ISequenceObserver
 {
 public :
   ReservoirInterfaceUpdater(ToyReactiveTransportCouplageDtLocalModule* parent)
   : m_parent(parent)
   {}
   void update()
   {
     m_parent->computeDirichletOverlapForReservoir() ;
   }
  private :
   ToyReactiveTransportCouplageDtLocalModule* m_parent ;
 };
 friend class ReservoirInterfaceUpdater ;

 class WindowInterfaceUpdater : public INumericalModel::ISequenceObserver
 {
 public :
   WindowInterfaceUpdater(ToyReactiveTransportCouplageDtLocalModule* parent)
   : m_parent(parent)
   {}
   void update()
   {
     Real current_time = m_parent->m_fine_time_mng->getCurrentTime() ;
     Real dt_local = m_parent->m_fine_time_mng->getCurrentTimeStep() ;
     m_parent->computeVFDirichletOverlapForWindow(current_time,
         dt_local, m_parent->m_val_limit1,m_parent->m_val_limit2) ;
   }
  private :
   ToyReactiveTransportCouplageDtLocalModule* m_parent ;
 };
 friend class WindowInterfaceUpdater ;
};

#endif /* ARCANEDEMO_DTLOCAL_TOYREACTIVETRANSPORTCOUPLAGEDTLOCALMODULE_H */
