// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
#include "Flow/FluxTerm/FluxTermMngService.h"
/* Author : haeberlf at Wed Aug 27 16:50:27 2008
 * Generated by createNew
 */

#include <sstream>

#include <arcane/ITimeLoopMng.h>

#include "Utils/Utils.h"
#include "Utils/ItemTools.h"
#include "Utils/ItemGroupBuilder.h"

#include "Appli/IAppServiceMng.h"

#include "Numerics/BCs/IBoundaryCondition.h"
#include "Numerics/BCs/IBoundaryConditionMng.h"
#include "Numerics/DiscreteOperator/CoefficientArray.h"

#include "ExpressionParser/IExpressionParser.h"
#include "ExpressionParser/IXYZTFunction.h"


#include "Numerics/LinearSolver/Impl/VariableUpdateImpl.h"

#include <cmath>

using namespace Arcane;

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
FluxTermMngService::init()
{
  //-----------------------------------------------------------------------------
  // Application Service Manager
  IServiceMng* service_mng = subDomain()->serviceMng();
  IAppServiceMng* app_service_mng = IAppServiceMng::instance(service_mng);

  //-----------------------------------------------------------------------------
  // Set Geometry Service
  info() << "Initialization Geometry Mng";
  m_geometry_service = app_service_mng->find<IGeometryMng> (true);
  if (m_geometry_service == NULL)
    error() << "Geometry service not found";

  //-----------------------------------------------------------------------------
  // Build Global Cell and Face Groups
  ItemGroupBuilder<Cell> cell_builder(ownCells().mesh(), "CELLS");
  ENUMERATE_CELL(icell,ownCells())
    {
      const Cell& cell = *icell;
      cell_builder.add(cell);
    }
  m_cells = cell_builder.buildGroup();

  ItemGroupBuilder<Face> faces_builder(ownFaces().mesh(), "FACES");
  ENUMERATE_FACE(iF, ownFaces())
    {
      const Face& F = *iF;
      faces_builder.add(F);
    }
  m_faces = faces_builder.buildGroup();
}

/*---------------------------------------------------------------------------*/

void
FluxTermMngService::prepareOperator()
{
  //---------------------------------------
  info() << "Prepare Groups and Stencils";

  // Build Internal and Boundary Face Groups
  ItemGroupBuilder<Face> internal_faces_builder(ownFaces().mesh(), "INTERNAL_FACES");
  ItemGroupBuilder<Face> boundary_faces_builder(ownFaces().mesh(), "BOUNDARY_FACES");

  ENUMERATE_FACE(iF, ownFaces())
    {
      const Face& F = *iF;
      if(F.isBoundary())
        {
          boundary_faces_builder.add(F);
        }
      else
        {
          internal_faces_builder.add(F);
        }
    }

  m_internal_faces = internal_faces_builder.buildGroup();
  m_boundary_faces = boundary_faces_builder.buildGroup();

  // Check if groups already defined, otherwise create them
  m_c_internal_faces = m_internal_faces.itemFamily()->findGroup("C_INTERNAL_FACES", true);
  m_cf_internal_faces = m_internal_faces.itemFamily()->findGroup("CF_INTERNAL_FACES", true);

  // CoefficientArrayT for cell and face coefficients
  m_cell_coefficients.reset(new CoefficientArrayT<Cell> (ownFaces(), allCells()));
  m_face_coefficients.reset(new CoefficientArrayT<Face> (ownFaces(), m_boundary_faces));

  //-------------------------------------
  info() << "Prepare Flow Operator";

  m_op->init();
  m_op->prepare(m_internal_faces, m_boundary_faces, m_c_internal_faces, m_cf_internal_faces, m_cell_coefficients.get(),
      m_face_coefficients.get());

  info() << "Flow Operator Prepared";

  // Prepare Geometry
  prepareGeometryService();

}

/*---------------------------------------------------------------------------*/
void
FluxTermMngService::prepareGeometryService()
{
  info() << "Prepare Geometry";

  // Get relevant geometric properties for operator
  m_geometry_service->addItemGroupProperty(m_op->cells(), m_op->getCellGeometricProperties());
  m_geometry_service->addItemGroupProperty(m_op->faces(), m_op->getFaceGeometricProperties());

  // Relevant geometric properties for boundary conditions
  m_geometry_service->addItemGroupProperty(ownFaces(), IGeometryProperty::PCenter);

  m_geometry_service->update();
}

/*---------------------------------------------------------------------------*/

void
FluxTermMngService::getOperatorGroups()
{
  /*TODO : Est inutile ou dangereux dans le cas ou l'operateur est
   * initialise par le meme service comme ici ? */

  info() << "Retrieving relevant item groups from operator";

  m_c_internal_faces = m_op->cInternalFaces();
  m_cf_internal_faces = m_op->cfInternalFaces();
  m_boundary_faces = m_op->boundaryFaces();
  m_internal_faces = m_op->internalFaces();
  m_faces = m_op->faces();

  info() << "-------------------------------------------------";
  info() << "  -- " << m_c_internal_faces.size() << " (c) internal faces";
  info() << "  -- " << m_cf_internal_faces.size() << " (cf) internal faces";
  info() << "  -- " << m_boundary_faces.size() << " boundary faces";
  info() << "  -- " << m_internal_faces.size() << " internal faces";
  info() << "  -- " << m_faces.size() << " total faces";
  info() << "  -- " << m_cells.size() << " cells";
  info() << "-------------------------------------------------";
}

/*---------------------------------------------------------------------------*/

void
FluxTermMngService::clearOperator()
{
  m_c_internal_faces.clear();
  m_cf_internal_faces.clear();
}

/*---------------------------------------------------------------------------*/

void
FluxTermMngService::addCInternalFacesContribution(
    LinearSystemOneStepBuilder* system_builder,
    IIndexManager* index_manager,
    IIndexManager::Equation flow_eq,
    IIndexManager::Entry u_entry)
{
ENUMERATE_FACE(iF, m_c_internal_faces)
  {
    const Face& F = *iF;

    ItemVectorView c_stencilF = m_cell_coefficients->stencil(F);
    const Cell& T0 = F.backCell(); // back cell
    const Cell& T1 = F.frontCell(); // front cell
    ConstArrayView<Real> cell_coefficients_F = m_cell_coefficients->coefficients(F);

    // May be improved using a global array
    Array<Integer> entry_indices(m_cell_coefficients->stencilSize(F));

    index_manager->getEntryIndex(u_entry,
        m_cell_coefficients->stencil(F),
        entry_indices);

    if(T0.isOwn())
    system_builder->addData(
        index_manager->getEquationIndex(flow_eq, T0),
        1.,
        entry_indices,
        m_cell_coefficients->coefficients(F));

    if(T1.isOwn())
    system_builder->addData(
        index_manager->getEquationIndex(flow_eq, T1),
        -1.,
        entry_indices,
        m_cell_coefficients->coefficients(F));
  }
}

/*---------------------------------------------------------------------------*/

void
FluxTermMngService::addCFInternalFacesContribution(
    LinearSystemOneStepBuilder* system_builder,
    IIndexManager* index_manager,
    IIndexManager::Equation flow_eq,
    IIndexManager::Entry u_entry,
    IIndexManager::Entry uboundary_entry)
{
ENUMERATE_FACE(iF, m_cf_internal_faces)
  {
    const Face& F = *iF;

    const ItemVectorView& f_stencilF = m_face_coefficients->stencil(F);
    //const ItemVectorView& c_stencilF = m_cell_coefficients->stencil(F);

    const IGeometryMng::Real3GroupMap& f_centers = m_geometry_service->getReal3GroupMapProperty(m_faces, IGeometryProperty::PCenter);

    const Cell& T0 = F.backCell(); // back cell
    const Cell& T1 = F.frontCell(); // front cell

    if (T0.isOwn() || T1.isOwn())
      {
        IIndexManager::EquationIndex flow_eq_T0 = T0.isOwn() ? index_manager->getEquationIndex(flow_eq, T0) : -1;
        IIndexManager::EquationIndex flow_eq_T1 = T1.isOwn() ? index_manager->getEquationIndex(flow_eq, T1) : -1;

        ConstArrayView<Real> cell_coefficients_F = m_cell_coefficients->coefficients(F);

        // --------------------------------------------------------------------------------------
        // Cell coefficients
        Array<Integer> entry_indices(m_cell_coefficients->stencilSize(F));
        index_manager->getEntryIndex(u_entry, m_cell_coefficients->stencil(F), entry_indices);

        if(T0.isOwn())
        system_builder->addData(
            index_manager->getEquationIndex(flow_eq, T0),
            1.,
            entry_indices,
            m_cell_coefficients->coefficients(F));

        if(T1.isOwn())
        system_builder->addData(
            index_manager->getEquationIndex(flow_eq, T1),
            -1.,
            entry_indices,
            m_cell_coefficients->coefficients(F));

        // --------------------------------------------------------------------------------------
        // Face coefficients

        ArrayView<Real> face_coefficients_F = m_face_coefficients->coefficients(F);
        int f_i = 0;
        for(ItemEnumerator Fi_it = f_stencilF.enumerator(); Fi_it.hasNext(); ++Fi_it)
          {
            const Face& Fi = (*Fi_it).toFace();
            Real taui = face_coefficients_F[f_i++];

            IBoundaryCondition* bc_Fi = m_bc_flow_mng->getBoundaryCondition(Fi);

            switch(bc_Fi->getType())
              {
                case BoundaryConditionTypes::Dirichlet :
                  {
                    const Real3& C_Fi = f_centers[Fi];
                    Real bc_Fi_value = bc_Fi->eval(C_Fi, 0.);
                    if(T0.isOwn()) system_builder->addRHSData(flow_eq_T0, -taui * bc_Fi_value);
                    if(T1.isOwn()) system_builder->addRHSData(flow_eq_T1, taui * bc_Fi_value);
                    break;
                  }
                default :
                  {
                    IIndexManager::EntryIndex uhb_Fi = index_manager->getEntryIndex(uboundary_entry, Fi);
                    if(T0.isOwn()) system_builder->addData(flow_eq_T0, uhb_Fi, taui);
                    if(T1.isOwn()) system_builder->addData(flow_eq_T1, uhb_Fi, -taui);
                    break;
                  }
              }
          }
      }
  }
}

/*---------------------------------------------------------------------------*/

void
FluxTermMngService::addBoundaryFacesContribution(
    LinearSystemOneStepBuilder* system_builder,
    IIndexManager* index_manager,
    IIndexManager::Equation flow_eq,
    IIndexManager::Entry u_entry,
    IIndexManager::Entry uboundary_entry)
{
ENUMERATE_FACE(iF, m_boundary_faces.own())
  {
    const Face& F = *iF;

    // boundary cell
    const Cell& T0 = F.boundaryCell();
    if(!T0.isOwn()) fatal() << "Boundary cell expected to be own";

    // Get equation index
    IIndexManager::EquationIndex flow_eq_T0 = index_manager->getEquationIndex(flow_eq, T0);

    addEquationBoundaryFaceContribution(
        system_builder,
        index_manager,
        flow_eq_T0,
        F,
        u_entry,
        uboundary_entry);
  }
}

/*---------------------------------------------------------------------------*/

void
FluxTermMngService::addBoundaryNonDirichletFacesContribution(
    LinearSystemOneStepBuilder* system_builder,
    IIndexManager* index_manager,
    IIndexManager::Equation boundary_eq,
    IIndexManager::Entry u_entry,
    IIndexManager::Entry uboundary_entry)
{
ENUMERATE_FACE(iF, m_boundary_faces.own())
  {

    const Face& F = *iF;

    // Get boundary condition pointer
    IBoundaryCondition* bc_F = m_bc_flow_mng->getBoundaryCondition(F);

    switch(bc_F->getType())
      {
        case BoundaryConditionTypes::Dirichlet :
          {
            // no equation for this Face
            break;
          }
        default:
          {
            // Get equation index
            IIndexManager::EquationIndex flow_eq_F = index_manager->getEquationIndex(boundary_eq, F);

            // Add RHS contribution
            const IGeometryMng::Real3GroupMap& f_centers = m_geometry_service->getReal3GroupMapProperty(m_faces, IGeometryProperty::PCenter);
            const IGeometryMng::Real3GroupMap& f_normals = m_geometry_service->getReal3GroupMapProperty(m_faces, IGeometryProperty::PNormal);
            const Real3 C_F = f_centers[F];
            const Real3 n_F = f_normals[F];
            Real bc_F_value = bc_F->eval(C_F, 0.);
            Real meas_F = math::sqrt(math::scaMul(n_F, n_F));
            system_builder->addRHSData(flow_eq_F, meas_F * bc_F_value);

            addEquationBoundaryFaceContribution(
                system_builder,
                index_manager,
                flow_eq_F,
                F,
                u_entry,
                uboundary_entry);
            break;
          }
      }
  }
}

/*---------------------------------------------------------------------------*/

void
FluxTermMngService::addEquationBoundaryFaceContribution(
    LinearSystemOneStepBuilder* system_builder,
    IIndexManager* index_manager,
    IIndexManager::EquationIndex flow_eq_F,
    const Face& F,
    IIndexManager::Entry u_entry,
    IIndexManager::Entry uboundary_entry)
{
  ItemVectorView c_stencilF = m_cell_coefficients->stencil(F);
  ItemVectorView f_stencilF = m_face_coefficients->stencil(F);

  // Get geometrical properties
  const IGeometryMng::Real3GroupMap& f_centers = m_geometry_service->getReal3GroupMapProperty(m_faces,
      IGeometryProperty::PCenter);

  ConstArrayView<Real> cell_coefficients_F = m_cell_coefficients->coefficients(F);
  ConstArrayView<Real> face_coefficients_F = m_face_coefficients->coefficients(F);

  // ---------------------------------------------------------------------------------------
  // Cell coefficients
  int c_i = 0;
  for (ItemEnumerator Ti_it = c_stencilF.enumerator(); Ti_it.hasNext(); ++Ti_it)
    {
      const Cell& Ti = (*Ti_it).toCell();

      Real taui = cell_coefficients_F[c_i++];
      IIndexManager::EntryIndex u_Ti = index_manager->getEntryIndex(u_entry, Ti);

      system_builder->addData(flow_eq_F, u_Ti, taui);
    }

  // ---------------------------------------------------------------------------------------
  // Face coefficients
  int f_i = 0;
  for (ItemEnumerator Fi_it = f_stencilF.enumerator(); Fi_it.hasNext(); ++Fi_it)
    {
      const Face& Fi = (*Fi_it).toFace();
      Real taui = face_coefficients_F[f_i++];

      IBoundaryCondition* bc_Fi = m_bc_flow_mng->getBoundaryCondition(Fi);

      switch (bc_Fi->getType())
        {
      case BoundaryConditionTypes::Dirichlet:
        {
          //Get boundary value
          const Real3& C_Fi = f_centers[Fi];
          Real bc_Fi_value = bc_Fi->eval(C_Fi, 0.);

          system_builder->addRHSData(flow_eq_F, -taui * bc_Fi_value);
          break;
        }
      default:
        {
          IIndexManager::EntryIndex uboundary_Fi = index_manager->getEntryIndex(uboundary_entry, Fi);
          system_builder->addData(flow_eq_F, uboundary_Fi, taui);
          break;
        }
        }
    }
}

/*---------------------------------------------------------------------------*/
void
FluxTermMngService::computeCInternalFacesFluxValues(
    VariableFaceReal* ptr_face_normal_flux_velocity,
    const VariableCellReal& cell_pressure)
{
ENUMERATE_FACE(iF, m_c_internal_faces)
  {
    const Face& F = *iF;

    ItemVectorView c_stencilF = m_cell_coefficients->stencil(F);
    ConstArrayView<Real> cell_coefficients_F = m_cell_coefficients->coefficients(F);

    int i = 0;
    for(ItemEnumerator Ti_it = c_stencilF.enumerator(); Ti_it.hasNext(); ++Ti_it)
      {
        const Cell& Ti = (*Ti_it).toCell();
        Real taui = cell_coefficients_F[i++];

        // add values to flux
        (*ptr_face_normal_flux_velocity)[F] += cell_pressure[Ti] * taui;
      }
  }
}

/*---------------------------------------------------------------------------*/
void
FluxTermMngService::computeCFInternalFacesFluxValues(VariableFaceReal* ptr_face_normal_flux_velocity,
    const VariableCellReal& cell_pressure,
    const VariableFaceReal& boundary_pressure)
{
  // Get geometrical properties
  const IGeometryMng::Real3GroupMap& f_centers = m_geometry_service->getReal3GroupMapProperty(m_faces,
      IGeometryProperty::PCenter);

  ENUMERATE_FACE(iF, m_cf_internal_faces)
  {
    const Face& F = *iF;
    const ItemVectorView& f_stencilF = m_face_coefficients->stencil(F);
//    const ItemVectorView& c_stencilF = m_cell_coefficients->stencil(F);

    // back cell
    const Cell& T0 = F.backCell(); // back cell
    const Cell& T1 = F.frontCell(); // front cell
    if (T0.isOwn() || T1.isOwn())
      {
        ConstArrayView<Real> cell_coefficients_F = m_cell_coefficients->coefficients(F);

        // Cell coefficients
        // Store Flux contribution for cells
        int i = 0;
        ItemVectorView c_stencilF = m_cell_coefficients->stencil(F);
        for(ItemEnumerator Ti_it = c_stencilF.enumerator(); Ti_it.hasNext(); ++Ti_it)
          {
            const Cell& Ti = (*Ti_it).toCell();
            Real taui = cell_coefficients_F[i++];
            (*ptr_face_normal_flux_velocity)[F] += cell_pressure[Ti] * taui;
          }

        // Face coefficients
        ArrayView<Real> face_coefficients_F = m_face_coefficients->coefficients(F);
        int f_i = 0;
        for(ItemEnumerator Fi_it = f_stencilF.enumerator(); Fi_it.hasNext(); ++Fi_it)
          {
            const Face& Fi = (*Fi_it).toFace();
            Real taui = face_coefficients_F[f_i++];

            IBoundaryCondition* bc_Fi = m_bc_flow_mng->getBoundaryCondition(Fi);

            switch(bc_Fi->getType())
              {
                case BoundaryConditionTypes::Neumann :
                  {
                    (*ptr_face_normal_flux_velocity)[F] += boundary_pressure[Fi] * taui;
                    break;
                  }
                case BoundaryConditionTypes::Dirichlet :
                  {
                    const Real3& C_Fi = f_centers[Fi];
                    Real bc_Fi_value = bc_Fi->eval(C_Fi, 0.);
                    (*ptr_face_normal_flux_velocity)[F] += bc_Fi_value * taui;
                    break;
                  }
                default:
                error() << "Boundary condition type not implemented";
              }
          }
      }
  }
}

/*---------------------------------------------------------------------------*/
void
FluxTermMngService::computeBoundaryFacesFluxValues(VariableFaceReal* ptr_face_normal_flux_velocity,
    const VariableCellReal& cell_pressure,
    const VariableFaceReal& boundary_pressure)
{
  // Get geometrical properties
  const IGeometryMng::Real3GroupMap& f_centers = m_geometry_service->getReal3GroupMapProperty(m_faces,
      IGeometryProperty::PCenter);

ENUMERATE_FACE(iF, m_boundary_faces.own())
  {
    const Face& F = *iF;

    ItemVectorView c_stencilF = m_cell_coefficients->stencil(F);
    ItemVectorView f_stencilF = m_face_coefficients->stencil(F);

    // boundary cell
    const Cell& T0 = F.boundaryCell();
    if(!T0.isOwn()) fatal() << "Boundary cell expected to be own";

    // Determine output-face orientation
    const Real alpha = (F.backCell() == T0) ? 1. : -1.;

    ConstArrayView<Real> cell_coefficients_F = m_cell_coefficients->coefficients(F);
    ConstArrayView<Real> face_coefficients_F = m_face_coefficients->coefficients(F);

    // Cell coefficients
    int c_i = 0;
    for(ItemEnumerator Ti_it = c_stencilF.enumerator(); Ti_it.hasNext(); ++Ti_it)
      {
        const Cell& Ti = (*Ti_it).toCell();
        Real taui = cell_coefficients_F[c_i++];
        (*ptr_face_normal_flux_velocity)[F] += alpha * cell_pressure[Ti] * taui;
      }

    // Face coefficients
    int f_i = 0;
    for(ItemEnumerator Fi_it = f_stencilF.enumerator(); Fi_it.hasNext(); ++Fi_it)
      {
        const Face& Fi = (*Fi_it).toFace();
        Real taui = face_coefficients_F[f_i++];
        IBoundaryCondition* bc_Fi = m_bc_flow_mng->getBoundaryCondition(Fi);
        const Real3& C_Fi = f_centers[Fi];
        Real bc_Fi_value = bc_Fi->eval(C_Fi, 0.);
        switch(bc_Fi->getType())
        {
          case BoundaryConditionTypes::Neumann :
            {
              (*ptr_face_normal_flux_velocity)[F] += alpha * boundary_pressure[Fi] * taui;
              break;
              }
            case BoundaryConditionTypes::Dirichlet :
              {
                (*ptr_face_normal_flux_velocity)[F] += alpha * bc_Fi_value * taui;
                break;
                }
            default:
            error() << "Boundary condition type not implemented";
          }
      }
  }
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

ARCANE_REGISTER_SERVICE_FLUXTERMMNG(FluxTermMng,FluxTermMngService);
