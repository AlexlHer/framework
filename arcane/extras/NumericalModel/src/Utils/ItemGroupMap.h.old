// -*- C++ -*-
#ifndef ITEMGROUPMAP_H
#define ITEMGROUPMAP_H

#include <arcane/utils/HashTableMap.h>
#include <arcane/Item.h>
#include <arcane/ItemGroup.h>
#include <arcane/ItemGroupRangeIterator.h>
#include <arcane/ItemEnumerator.h>
#include <arcane/IVariableComputeFunction.h>
#include <arcane/utils/ITraceMng.h>
#include <arcane/utils/Trace.h>
#include <arcane/ArcaneVersion.h>
#include <arcane/utils/NotImplementedException.h>

#include <arcane/ItemVectorView.h>
#include <arcane/mesh/ItemFamily.h>

#define USE_NEW_ITEMGROUPMAP

/*---------------------------------------------------------------------------*/
#if defined(ITEMGROUP_USE_OBSERVERS) && defined(USE_NEW_ITEMGROUPMAP)
/*---------------------------------------------------------------------------*/

/* Spécialement pour certains tests de CooresArcane */
// #define ITEMGROUPMAP_FILLINIT
#include "Utils/ItemGroupMap_new.h"

/*---------------------------------------------------------------------------*/
#else /* ITEMGROUP_USE_OBSERVERS */
/*---------------------------------------------------------------------------*/

#include <arcane/IVariable.h>
#include <arcane/mesh/DynamicMeshKindInfos.h>
#include <arcane/utils/CArrayAll.h>
#include <map>

using namespace Arcane;

/*---------------------------------------------------------------------------*/
#if (ARCANE_VERSION<10600)
class ItemGroupMapAbstract
#else
class ARCANE_GEOMETRY_EXPORT ItemGroupMapAbstract
#endif
{
public:
  enum Property {
    eResetOnResize     = 1<<1,
    eRecomputeOnResize = 1<<2
  };

public:
  //! Constructeur
  ItemGroupMapAbstract() 
    : m_group(ItemGroupImpl::checkSharedNull()),
      m_variable(NULL),
      m_properties(eResetOnResize)
  {
    ;
  }
    
  //! Destructeur
  virtual ~ItemGroupMapAbstract();

  //! Initialisation sur un nouveau groupe
  virtual void init(const ItemGroup & group) = 0;

  //! Accès aux stats
  /*! Inclus la description des collisions */
  virtual void stats(std::ostream & o) = 0;

  //! Accès au groupe associé
  virtual ItemGroup group() const { return m_group; }

  //! Controle la cohérence du groupe avec le groupe de référence
  virtual bool checkSameGroup(const ItemGroup & group) const;

  //! Controle la cohérence du groupe avec le groupe de référence
  virtual bool checkSameGroup(const ItemVectorView & group) const;

  //! Accès aux propriétés (lecture seule)
  virtual const Integer & properties() const { return m_properties; }

  //! Accès aux properties (lecture/écriture)
  virtual Integer & properties() { return m_properties; }

  //! Nom de l'objet
  String name() const;

protected:
  //! Ami avec classe Gestionnaire de Variable (au sens Arcane)
  friend class ItemGroupMapAbstractVariable;

  //! Accès à la IVariable sous-jascente
  virtual IVariable * variable() const { return m_variable; }
  
  //! Initialisation de bas niveau
  void _init(const ItemGroup & group);

  //! Redimensionnement
  /*! Ne change pas les localIds des Items */
  virtual void _resizeFromGroup() = 0;

  //! Compactage
  /*! Ne change pas le nombre de items du group
   *  Appelé par le ItemGroupMapAbstractVariable
   * \warning le compactage de la variable est appelé avec la renumérotation effective du groupe 
   * \warning le compactage n'induit pas de changement de taille
   */
  virtual void _compact(Int32ConstArrayView new_to_old_ids) = 0;

  virtual void _compact2(Int32ConstArrayView new_to_old_ids) = 0;

  virtual void _changeGroupIds(Int32ConstArrayView old_to_new_ids) = 0;

  virtual void _copyItemsValues(Int32ConstArrayView source, Int32ConstArrayView destination) = 0;

  //! Taille du container
  /*! Sert principalement au debuggage */
  virtual Integer _size() = 0;

  //! Test l'intégrité de l'ItemGroupMap relativement à son groupe
  virtual bool _checkGroupIntegrity() const = 0;

protected:
  //! Accès aux traces
  virtual ITraceMng * traceMng() const;

protected:
  ItemGroupImpl * m_group; //!< Groupe associé
  IVariable * m_variable; //!< Variable représentant la connexion à son groupe
  Integer m_properties;
};

/*---------------------------------------------------------------------------*/

//! Classe d'implémentation des parties communes aux ItemGroupMap
/*! \todo optimiser la table de hachage vu que l'on connait l'ensemble
 *  des indices à la construction (les collisions sont consultables via stats())
 */
template<typename ValueType>
class ItemGroupMapAbstractImplT
  : protected HashTableBase,
    public ItemGroupMapAbstract
{
public:
  typedef Integer KeyTypeValue;
  typedef HashTraitsT<KeyTypeValue> KeyTraitsType;
  typedef typename KeyTraitsType::KeyTypeConstRef KeyTypeConstRef;
  //   typedef typename KeyTraitsType::KeyTypeValue KeyTypeValue;
  typedef ItemGroupMapAbstractImplT<ValueType> ThatClass;

protected:
  struct Data
  {
  public:
    Data() 
      : m_key((KeyTypeValue)(-1))
      , m_value(ValueType()), m_next(0) {}
  public:
    Data* next() const { return m_next; }
    KeyTypeConstRef key() const { return m_key; }
    const ValueType& value() const { return m_value; }
    ValueType& value() { return m_value; }
  public:
    KeyTypeValue m_key; //!< Clé de recherche
    ValueType m_value; //!< Valeur de l'élément
    Data* m_next; //! Elément suivant dans la table de hachage
  };

public:

  //! \brief Constructeur d'une table vide
  ItemGroupMapAbstractImplT()
    : HashTableBase(0,false)
    , ItemGroupMapAbstract()
  {
    ;
  }

  /*! \brief Constructeur d'une table de taille \a buffer_size
   *
   * Utilise la fonction nearestPrimeNumber() pour avoir une taille
   * interne de hachage qui est soit nombre premier.
   */  
  ItemGroupMapAbstractImplT(const ItemGroup & group)
    : HashTableBase(0,false)
    , ItemGroupMapAbstract()
  {
    init(group);
  }
  
  //! Destructeur
  virtual ~ItemGroupMapAbstractImplT()
  {
    ;
  }

protected :
  virtual bool _hasDefaultValue() const = 0;
  virtual ValueType _getDefaultValue() const = 0;

private:
  //! Constructeur par copie
  /*! Zone privé + non défini => usage interdit */
  ItemGroupMapAbstractImplT(const ItemGroupMapAbstractImplT &);

  //! Opérateur de recopie
  /*! Zone privé + non défini => usage interdit */
  const ThatClass& operator=(const ThatClass& from);

public:
  void init(const ItemGroup & group)
  {
    _init(group);

    const Integer group_size = group.size();
    m_nb_bucket = this->nearestPrimeNumber(2*group_size);
    m_buckets.resize(m_nb_bucket);
    m_buckets.fill(0);
    m_buffer.resize(group_size);

    const bool hasDefaultValue = _hasDefaultValue();
    const ValueType default_value = _getDefaultValue();
    for( ItemGroupRangeIterator i(group) ; i.hasNext(); ++i)
      {
        const KeyTypeConstRef key = i.itemLocalId();
        const Integer bucket = _hash(key);
        ARCANE_ASSERT( (_lookupBucket(bucket,key) == NULL), ("Already assigned key"));
        Data & hd = m_buffer[i.index()];
        hd.m_key = key;
        hd.m_next = m_buckets[bucket];
        if (hasDefaultValue)
          hd.m_value = default_value;
        else
          hd.m_value = ValueType();
        m_buckets[bucket] = &hd;
      }
  }

  void stats(std::ostream & o)
  {
    Integer collision_count = 0;
    for(Integer i=0; i < m_buffer.size(); ++i)
      {
        for(Data * hd = &m_buffer[i]; hd->next(); hd = hd->next())
          {
            o << "Collision in bucket " << i << " / " << m_nb_bucket << " between : " 
              << hd->key() << "(" << KeyTraitsType::hashFunction(hd->key()) << ") and "
              << hd->next()->key() << "(" << KeyTraitsType::hashFunction(hd->next()->key()) << ")\n";
            ++collision_count;
          }
      }
    o << "ItemGroupMapAbstractImplT::stats : Collision count = " << collision_count << " / " << m_buffer.size() << "\n";
  }

protected:
  virtual void _resizeFromGroup() 
  {
    Trace::Setter setter(traceMng(),"ItemGroupMapAbstractImplT");
    if ((m_properties & eResetOnResize) &&
        (m_properties & eRecomputeOnResize))
      traceMng()->fatal() << "Incompatible ItemGroupMap flags";

    if (m_properties & eResetOnResize) {
      init(m_group);
    } else if (m_properties & eRecomputeOnResize) {
      init(m_group);
      if (variable()->computeFunction() != NULL)
        variable()->computeFunction()->execute();
      else
        traceMng()->error() << "ComputeFunction requested but not defined";
    } else {
      const Integer old_size = m_buffer.size();
      const Integer new_size = m_group->size();
      m_nb_bucket = this->nearestPrimeNumber(2*new_size);
      m_buckets.resize(m_nb_bucket);
      m_buckets.fill(0);
      
      CArrayT<Data> old_buffer;
      old_buffer.setArray(m_buffer); // Echange des données sans recopie
      m_buffer.setArray(CArrayT<Data>());
      m_buffer.resize(new_size);

      std::map<Integer,Data*> old_lid_to_data;
      for(Integer i=0;i<old_size;++i)
        {
          old_lid_to_data[old_buffer[i].key()] = &old_buffer[i];
          traceMng()->debug(Trace::Highest) << i << ": Known old lid : " << old_buffer[i].key();
        }

      const bool hasDefaultValue = _hasDefaultValue();
      const ValueType default_value = _getDefaultValue();
      ENUMERATE_ITEM(i,group())
        {
          const KeyTypeConstRef key = i.itemLocalId();
          const Integer bucket = _hash(key);
          ARCANE_ASSERT( (_lookupBucket(bucket,key) == NULL), ("Already assigned key"));
          Data & hd = m_buffer[i.index()];
          hd.m_key = key;
          hd.m_next = m_buckets[bucket];
          m_buckets[bucket] = &hd;

          typename std::map<Integer,Data*>::iterator idata = old_lid_to_data.find(key);
          if (idata != old_lid_to_data.end()) {
            hd.m_value = idata->second->m_value;
          } else {
            traceMng()->debug(Trace::Highest) << "Default value for lid " << hd.key();
            if (hasDefaultValue)
              hd.m_value = default_value;
            else
              hd.m_value = ValueType();
          }
          // To enable this debug line, m_value must be a printable type
          // traceMng()->debug(Trace::Highest) << i.index() << ": New Uid/lid : " << (*i).uniqueId() << " " << (*i).localId() 
          //                                   << " : value = " << hd.m_value << " chk=" << hasKey(*i);
        }
    }
    _checkGroupIntegrity();    
  }

  virtual void _compact(Int32ConstArrayView new_to_old_ids)
  {
    // La taille du groupe n'a pas changé mais on réordonne les données
    m_buckets.fill(0);

    const Integer size = m_buffer.size();

    CArrayT<Data> old_buffer; 
    old_buffer.setArray(m_buffer); // Echange des données sans recopie
    m_buffer.setArray(CArrayT<Data>());
    m_buffer.resize(size);

    std::map<Integer,Data*> old_lid_to_data;
    for(Integer i=0;i<size;++i)
      {
        old_lid_to_data[old_buffer[i].key()] = &old_buffer[i];
        traceMng()->debug(Trace::Highest) << i << ": Known old lid : " << old_buffer[i].key();
      }

    std::map<Integer,Integer> new_to_old_sublids;
    for(Integer newid=0;newid<new_to_old_ids.size();++newid)
      {
        const Integer old_lid = new_to_old_ids[newid];
        if (old_lid_to_data.find(old_lid) != old_lid_to_data.end()) {
          new_to_old_sublids[newid] = old_lid;
        }
      }
    ARCANE_ASSERT(((Integer) new_to_old_sublids.size() == (Integer) m_group->size()),("Incompatible sizes after conversion"));

    Integer index = 0;
    for(std::map<Integer,Integer>::const_iterator i = new_to_old_sublids.begin(); 
        i != new_to_old_sublids.end(); ++i)
      {
        const KeyTypeConstRef key = i->first;
        const Integer bucket = _hash(key);
        ARCANE_ASSERT( (_lookupBucket(bucket,key) == NULL), ("Already assigned key"));
        const Integer old_lid = i->second;
        Data & hd = m_buffer[index++];
        hd.m_key = key;
        hd.m_next = m_buckets[bucket];
        m_buckets[bucket] = &hd;
        typename std::map<Integer,Data*>::iterator idata = old_lid_to_data.find(old_lid);
        ARCANE_ASSERT((idata != old_lid_to_data.end()),("Data not found"));
        hd.m_value = idata->second->m_value;
      }
  }

  virtual void _compact2(Int32ConstArrayView new_to_old_ids)
  {
    // La taille du groupe n'a pas changé mais on réordonne les données
    m_buckets.fill(0);

    mesh::ItemFamily * itemFamily = dynamic_cast<mesh::ItemFamily*>(m_group->itemFamily());
    const mesh::DynamicMeshKindInfos & infos = itemFamily->infos();
    const IntegerConstArrayView newToOldLocalIds = infos.newToOldLocalIds();
    //const IntegerConstArrayView oldToNewLocalIds = infos.oldToNewLocalIds();
    //ARCANE_ASSERT((newToOldLocalIds.size() == oldToNewLocalIds.size()),("Inconsistent heuristic"));

    if (newToOldLocalIds.size() == 0)
      { /* Compactage de Variable partielle depuis ItemGroupImpl::removeSupressedItems
         * Les groupes ayant des variables partielles (ie group() != allItems())
         *  sont immédiatement recompactés après suppression d'items
         * Dans ce cas le compactage est une suite strictement croissante (les trous sont les items supprimés)
         */
        traceMng()->debug(Trace::High) << "Use Local Compact";
        const Integer new_size = new_to_old_ids.size();
        ARCANE_ASSERT((new_size <= m_buffer.size()),("Inconsistent heuristic"));
        CArrayT<Data> old_buffer; 
        old_buffer.setArray(m_buffer); // Echange des données sans recopie
        m_buffer.setArray(CArrayT<Data>());
        m_buffer.resize(new_size);
        for(Integer i=0;i<new_size;++i) 
          {
            Data & old_data = old_buffer[new_to_old_ids[i]];
            const KeyTypeConstRef key = old_data.key();
            const Integer bucket = _hash(key);
            ARCANE_ASSERT( (_lookupBucket(bucket,key) == NULL), ("Already assigned key"));
            Data & hd = m_buffer[i];
            hd.m_key = key;
            hd.m_next = m_buckets[bucket];
            hd.m_value = old_data.m_value;
            m_buckets[bucket] = &hd;
          }
      }
    else
      { // Compactage par identification globale depuis ItemFamily::compactVariablesAndGroups
        traceMng()->debug(Trace::High) << "Use Global Compact";
        ARCANE_ASSERT((group().size() == m_buffer.size()),("Inconsistent heuristic"));
        ARCANE_ASSERT((group().size() <= new_to_old_ids.size()),("Inconsistent heuristic"));
        _compact(new_to_old_ids);
      }
    _checkGroupIntegrity();
  }

  virtual void _changeGroupIds(Int32ConstArrayView old_to_new_ids)
  {
    // La taille du groupe n'a pas changé mais on réordonne les données
    m_buckets.fill(0);

    // Pour l'instant, on renumérote les items mais on ne touche pas à l'ordre.
    const Integer size = m_buffer.size();
    for(Integer index = 0;index<size;++index) 
      {
        Data & hd = m_buffer[index];
        const KeyTypeConstRef key = old_to_new_ids[hd.m_key]; // new key
        const Integer bucket = _hash(key);
        ARCANE_ASSERT( (_lookupBucket(bucket,key) == NULL), ("Already assigned key"));
        hd.m_key = key;
        hd.m_next = m_buckets[bucket];
        m_buckets[bucket] = &hd;
      }
    _checkGroupIntegrity();
  }

  virtual void _copyItemsValues(Int32ConstArrayView source, Int32ConstArrayView destination)
  {
    const Integer size = source.size();
    for(Integer i=0;i<size;++i)
      {
        const Integer src_lid = source[i];
        const Integer dst_lid = destination[i];
        traceMng()->debug(Trace::Highest) << "Check source hasKey("<<src_lid<<"):"<<_hasKey(src_lid)
                                          << " target hasKey("<<dst_lid<<"):"<<_hasKey(dst_lid);
        Data * src_data = _lookupBucket(_hash(src_lid),src_lid);
        Data * dst_data = _lookupBucket(_hash(dst_lid),dst_lid);
        if (src_data == NULL || dst_data == NULL) continue;
        dst_data->m_value = src_data->m_value;
      }
  }

  Integer _size() 
  {
    return m_buffer.size(); 
  }

public:
  bool _checkGroupIntegrity() const {
    bool integrity = true;
    if (group().size() != m_buffer.size()) {
      traceMng()->error() << "ItemGroupMap BAD DATA size : group size=" << group().size() << " vs data size=" << m_buffer.size();
      integrity = false;
    }

    ENUMERATE_ITEM(item,group()) {
      const Data & hd = m_buffer[item.index()];
      if (hd.key() != (*item).localId() || !hasKey(*item)) {
        traceMng()->error() << "ItemGroupMap BAD DATA at " << item.index() << " :  lid=" << (*item).localId() << " vs key " << hd.key() << " chk:" << hasKey(*item);
        integrity = false;
      }
    }
    return integrity;
  }

public:
  /*! \brief Recherche la valeur correspondant à l'item \a item
   *
   * Une exception est générée si la valeur n'est pas trouvé.
   */
  inline const ValueType& operator[](const Item & item) const
  {
    Data* ht = _lookup(item.localId());
    if (ht)
      return ht->value();
    this->_throwNotFound();
    return m_null_value;
  }

  /*! \brief Recherche la valeur correspondant à l'item \a item
   *
   * Une exception est générée si la valeur n'est pas trouvé.
   */
  inline ValueType& operator[](const Item & item)
  {
    Data* ht = _lookup(item.localId());
    if (ht)
      return ht->value();
    this->_throwNotFound();
    return m_null_value;
  }

  /*! \brief Recherche la valeur correspondant à l'item associé à un iterateur
   */
  inline const ValueType& operator[](const ItemGroupRangeIterator & iter) const
  {
    ARCANE_ASSERT((_lookup(iter.itemLocalId()) == &m_buffer[iter.index()]),("Inconsistency detected on item id"));
    return m_buffer[iter.index()].value();
  }

  /*! \brief Recherche la valeur correspondant à l'item associé à un iterateur
   */
  inline ValueType& operator[](const ItemGroupRangeIterator & iter)
  {
    ARCANE_ASSERT((_lookup(iter.itemLocalId()) == &m_buffer[iter.index()]),("Inconsistency detected on item id"));
    return m_buffer[iter.index()].value();
  }

  /*! \brief Recherche la valeur correspondant à l'item associé à un énumérateur
   */
  inline const ValueType& operator[](const ItemEnumeratorT<Item> & iter) const
  {
    ARCANE_ASSERT((_lookup(iter.itemLocalId()) == &m_buffer[iter.index()]),("Inconsistency detected on item id"));
    return m_buffer[iter.index()].value();
  }

  /*! \brief Recherche la valeur correspondant à l'item associé à un énumérateur
   */
  inline ValueType& operator[](const ItemEnumeratorT<Item> & iter)
  {
    ARCANE_ASSERT((_lookup(iter.itemLocalId()) == &m_buffer[iter.index()]),("Inconsistency detected on item id"));
    return m_buffer[iter.index()].value();
  }

  inline bool hasKey(const Item & item) const
  {
    return _hasKey(item.localId());
  }

protected:
  //! Fonction de hachage
  /*! Utilise la fonction de hachage de Arcane même si quelques
   *  collisions sont constatées avec les petites valeurs */
  inline Integer _hash(KeyTypeConstRef id) const
  {
    ARCANE_ASSERT((_initialized()),("ItemGroupMap not initialized"));
    return (Integer)(KeyTraitsType::hashFunction(id) % m_nb_bucket);
  }

  //! \a true si une valeur avec la clé \a id est présente
  inline bool _hasKey(KeyTypeConstRef id) const
  {
    const Integer hf = _hash(id);
    for( Data* i = m_buckets[hf]; i; i=i->next() ) 
      {
        if (i->key()==id)
          return true;
      }
    return false;
  }

  //! Recherche d'une clef dans un bucket
  inline Data* _lookupBucket(Integer bucket, KeyTypeConstRef id) const
  { 
    ARCANE_ASSERT((_initialized()),("ItemGroupMap not initialized"));
    for( Data* i = m_buckets[bucket]; i; i=i->next() )
      {
        if (i->key()==id)
          return i;
      }
    return 0;
  }

  //! Recherche d'une clef dans toute la table
  inline Data* _lookup(KeyTypeConstRef id) const
  { 
    return _lookupBucket(_hash(id),id);
  }

  inline bool _initialized() const
  {
    return not m_buckets.empty();
  }

protected:
  CArrayT<Data> m_buffer; //!< Tampon d'allocation des valeurs
  ValueType m_null_value; //! Valeur nulle (non utilisée)
  BufferT<Data*> m_buckets; //! Tableau des buckets
};

/*---------------------------------------------------------------------------*/

//! \brief Classe de base pour les ItemGroupMap
/*  Contient la majorité des fonctionnalités mais sans distinction du
 *  type d'item/
 *
 *  Permet d'indéxer un tableau par les items d'un groupe. Ceci évite
 *  des erreurs principalement en parallèle ou certains items ne sont
 *  pas contigus en localId (et évite le bug d'indexé un Array via les
 *  localId des items).
 *
 *  Il n'est possible d'accèder qu'à des items du groupe
 *  original. Retourne une exception si l'item demandé n'est pas
 *  référencé. L'accès est optimiser pour les ItemGroupRangeIterator
 *
 *  Cette implémentation stocke les valeurs dans la structure Data de
 *  la table de hachage. Elle ne sert qu'à typer les Items.
 *
 * \see ItemGroupMapT et ItemGroupMapArrayT
 */
template <typename ValueType>
class ItemGroupMapBaseT : 
  public ItemGroupMapAbstractImplT<ValueType>
{
protected:
  typedef ItemGroupMapAbstractImplT<ValueType> BaseClass;

public:
  //! Constructeur par défaut
  ItemGroupMapBaseT() 
    : BaseClass()
    , m_has_default_value(false)
  {
    ;
  }
  
  //! Constructeur à partir d'un groupe
  ItemGroupMapBaseT(const ItemGroup & group) 
    : BaseClass()
    , m_has_default_value(false)
  {
    init(group);
  }

  //! Constructeur à partir d'un groupe
  ItemGroupMapBaseT(const ItemGroup & group, ValueType default_value)
    : BaseClass()
    , m_has_default_value(false)
  {
    setDefaultValue(default_value);
    init(group);
  }

  //! Destructeur
  virtual ~ItemGroupMapBaseT()
  {
    ;
  }
  
  //! Initialisation sur un nouveau groupe
  void init(const ItemGroup & group) 
  {
    // Met la valeur par défaut en association aux clefs
    BaseClass::init(group);
  }

  //! Opérateur d'accès à partir d'un item
  ValueType & operator[](const Item & item) 
  {
    return BaseClass::operator[](item);
  }

  //! Opérateur d'accès à partir d'un ItemGroupRangeIteratorT
  ValueType & operator[](const ItemGroupRangeIterator & iter)
  {
    return BaseClass::operator[](iter);
  }

  //! Opérateur d'accès en mode constant à partir d'un item
  const ValueType & operator[](const Item & item) const
  {
    return BaseClass::operator[](item);
  }

  //! Opérateur d'accès en mode constant à partir d'un ItemGroupRangeIteratorT
  const ValueType & operator[](const ItemGroupRangeIterator & iter) const
  {
    return BaseClass::operator[](iter);
  }

  //   /*! \brief Recherche la valeur correspondant à l'item associé à un énumérateur
  //    */
  //   inline const ValueType& operator[](const ItemInternalEnumerator & iter) const
  //   {
  //     return BaseClass::operator[](iter);    
  //   }

  //   /*! \brief Recherche la valeur correspondant à l'item associé à un énumérateur
  //    */
  //   inline ValueType& operator[](const ItemInternalEnumerator & iter)
  //   {
  //     return BaseClass::operator[](iter);
  //   }

  /*! \brief Recherche la valeur correspondant à l'item associé à un énumérateur
   */
  inline const ValueType& operator[](const ItemEnumerator & iter) const
  {
    return BaseClass::operator[](iter);    
  }

  /*! \brief Recherche la valeur correspondant à l'item associé à un énumérateur
   */
  inline ValueType& operator[](const ItemEnumerator & iter)
  {
    return BaseClass::operator[](iter);
  }

  //! Teste l'existence d'un item en temps que clef
  bool hasKey(const Item & item) const
  {
    return BaseClass::hasKey(item);
  }

  //! Définit une valeur par défaut de remplissage
  void setDefaultValue(const ValueType & default_value) { m_has_default_value = true; m_default_value = default_value; }
  
protected:
  bool m_has_default_value;
  ValueType m_default_value;
  bool _hasDefaultValue() const { return m_has_default_value; }
  ValueType _getDefaultValue() const { return m_default_value; }
};

/*---------------------------------------------------------------------------*/

/*! \brief Forme de tableau indéxé sur un groupe d'items de type ItemKind
 *
 *  Permet d'indéxer un tableau par les items d'un groupe. Ceci évite
 *  des erreurs principalement en parallèle ou certains items ne sont
 *  pas contigus en localId (et évite le bug d'indexé un Array via les
 *  localId des items).
 *
 *  Il n'est possible d'accèder qu'à des items du groupe
 *  original. Retourne une exception si l'item demandé n'est pas
 *  référencé. L'accès est optimiser pour les ItemGroupRangeIterator
 *
 *  Cette implémentation stocke les valeurs dans la structure Data de
 *  la table de hachage. Elle ne sert qu'à typer les Items.
 *
 * \see ItemGroupMapArrayT
 */
template <typename ItemKind, typename ValueType>
class ItemGroupMapT : 
  public ItemGroupMapAbstractImplT<ValueType>
{
protected:
  typedef ItemGroupMapAbstractImplT<ValueType> BaseClass;

public:
  //! Constructeur par défaut
  ItemGroupMapT()
    : BaseClass()
    , m_has_default_value(false)
  {
    ;
  }
  
  //! Constructeur à partir d'un groupe
  ItemGroupMapT(const ItemGroupT<ItemKind> & group) 
    : BaseClass()
    , m_has_default_value(false)
  {
    init(group);
  }

  //! Constructeur à partir d'un groupe
  ItemGroupMapT(const ItemGroupT<ItemKind> & group, ValueType default_value) 
    : BaseClass()
    , m_has_default_value(false)
  {
    setDefaultValue(default_value);
    init(group);
  }

  //! Destructeur
  virtual ~ItemGroupMapT()
  {
    ;
  }
  
  //! Initialisation sur un nouveau groupe
  void init(const ItemGroupT<ItemKind> & group) 
  {
    // Met la valeur par défaut en association aux clefs
    BaseClass::init(group);
  }

  //! Opérateur d'accès à partir d'un item
  ValueType & operator[](const ItemKind & item) 
  {
    return BaseClass::operator[](item);
  }

  //! Opérateur d'accès à partir d'un ItemGroupRangeIteratorT
  ValueType & operator[](const ItemGroupRangeIteratorT<ItemKind> & iter)
  {
    return BaseClass::operator[](iter);
  }

  //! Opérateur d'accès en mode constant à partir d'un item
  const ValueType & operator[](const ItemKind & item) const
  {
    return BaseClass::operator[](item);
  }

  //! Opérateur d'accès en mode constant à partir d'un ItemGroupRangeIteratorT
  const ValueType & operator[](const ItemGroupRangeIteratorT<ItemKind> & iter) const
  {
    return BaseClass::operator[](iter);
  }

  /*! \brief Recherche la valeur correspondant à l'item associé à un énumérateur
   */
  inline const ValueType& operator[](const ItemEnumeratorT<ItemKind> & iter) const
  {
    return BaseClass::operator[](iter);    
  }

  /*! \brief Recherche la valeur correspondant à l'item associé à un énumérateur
   */
  inline ValueType& operator[](const ItemEnumeratorT<ItemKind> & iter)
  {
    return BaseClass::operator[](iter);    
  }

  bool hasKey(const ItemKind & item) const
  {
    return BaseClass::hasKey(item);
  }

  //! Définit une valeur par défaut de remplissage
  void setDefaultValue(const ValueType & default_value) { m_has_default_value = true; m_default_value = default_value; }

protected:
  bool m_has_default_value;
  ValueType m_default_value;
  bool _hasDefaultValue() const { return m_has_default_value; }
  ValueType _getDefaultValue() const { return m_default_value; }
};

/*---------------------------------------------------------------------------*/

//! \brief Classe de base pour les ItemGroupMapArray
/*  Contient la majorité des fonctionnalités mais sans distinction du
 *  type d'item/
 *
 *  Permet d'indéxé un tableau par les items d'un groupe. Ceci évite
 *  des erreurs principalement en parallèle ou certains items ne sont
 *  pas contigus en localId (et évite le bug d'indexé un Array via les
 *  localId des items).
 *
 *  Il n'est possible d'accèder qu'à des items du groupe
 *  original. Retourne une exception si l'item demandé n'est pas
 *  référencé. L'accès en optimiser pour les ItemGroupRangeIterator
 *
 * \see ItemGroupMapT
 */

template <typename ValueType>
class ItemGroupMapArrayBaseT : 
  public ItemGroupMapAbstractImplT<ValueType*>
{
public:
  typedef ArrayView<ValueType> ArrayType;
  typedef ConstArrayView<ValueType> ConstArrayType;

protected:
  typedef ItemGroupMapAbstractImplT<ValueType*> BaseClass;
  Integer m_array_size;
  ValueType * m_array_data;
  bool m_has_default_value;
  ValueType m_default_value;

public:
  //! Constructeur par défaut
  ItemGroupMapArrayBaseT() 
    : BaseClass()
    , m_array_size(0)
    , m_array_data(NULL)
    , m_has_default_value(false)
  {
    ;
  }

  //! Constructeur à partir d'un groupe
  ItemGroupMapArrayBaseT(const ItemGroup & group, 
                         const Integer array_size)
    : BaseClass()
    , m_array_data(NULL)
    , m_has_default_value(false)
  {
    init(group,array_size);
  }

  //! Constructeur à partir d'un groupe
  ItemGroupMapArrayBaseT(const ItemGroup & group, 
                         const Integer array_size,
                         ValueType default_value) 
    : BaseClass()
    , m_array_data(NULL)
    , m_has_default_value(false)
  {
    setDefaultValue(default_value);
    init(group,array_size);
  }

  //! Destructeur
  virtual ~ItemGroupMapArrayBaseT()
  {
    delete[] m_array_data;
  }
  
  //! Initialisation sur un nouveau groupe
  void init(const ItemGroup & group, const Integer array_size) 
  {
    const Integer old_global_size = m_array_size * this->group().size();
    m_array_size = array_size;
    BaseClass::init(group);
    const Integer global_size = group.size()*m_array_size;
    if ((old_global_size != global_size) or (m_array_data == NULL)) {
      delete[] m_array_data;
      m_array_data = new ValueType[global_size];
    }
    if (m_has_default_value)
      for(Integer i=0;i<global_size;++i) m_array_data[i] = m_default_value;

    for( ItemGroupRangeIterator i(group); i.hasNext(); ++i )
      {
        ValueType * currentData = m_array_data + m_array_size * i.index();
        BaseClass::operator[](i) = currentData;
      }
  }

  //! Initialisation sans changement de taille des tableaux
  void init(const ItemGroup & group)
  {
    init(group,m_array_size);
  }

  //! Opérateur d'accès à partir d'un item
  /*! Retourne une exception si l'item n'est pas référencé */
  ArrayType operator[](const Item & item) 
  {
    return ArrayType(m_array_size,BaseClass::operator[](item));
  }

  //! Opérateur d'accès à partir d'un ItemGroupRangeIteratorT
  /*! Retourne une exception si l'item n'est pas référencé */
  ArrayType operator[](const ItemGroupRangeIterator & iter)
  {
    return ArrayType(m_array_size,BaseClass::operator[](iter));
  }

  /*! \brief Recherche la valeur correspondant à l'item associé à un énumérateur
   */
  inline ArrayType operator[](const ItemEnumerator & iter)
  {
    return ArrayType(m_array_size,BaseClass::operator[](iter));
  }

  //! Opérateur d'accès en mode constant à partir d'un item
  /*! Retourne une exception si l'item n'est pas référencé */
  ConstArrayType operator[](const Item & item) const
  {
    return ConstArrayType(m_array_size,BaseClass::operator[](item));
  }

  //! Opérateur d'accès en mode constant à partir d'un ItemGroupRangeIteratorT
  /*! Retourne une exception si l'item n'est pas référencé */
  ConstArrayType operator[](const ItemGroupRangeIterator & iter) const
  {
    return ConstArrayType(m_array_size,BaseClass::operator[](iter));
  }

  /*! \brief Recherche la valeur correspondant à l'item associé à un énumérateur
   */
  inline const ConstArrayType operator[](const ItemEnumerator & iter) const
  {
    return ConstArrayType(m_array_size,BaseClass::operator[](iter));
  }

  bool hasKey(const Item & item) const
  {
    return BaseClass::hasKey(item);
  }

public:
  void setDefaultValue(const ValueType & default_value) { m_has_default_value = true; m_default_value = default_value; }

protected:
  virtual void _resizeFromGroup() {
    if (this->m_properties & ItemGroupMapAbstract::eResetOnResize ||
        this->m_properties & ItemGroupMapAbstract::eRecomputeOnResize)
      this->traceMng()->fatal() << "ItemGroupMap properties not yet implemented on arrays";

    BaseClass::_resizeFromGroup();
    ItemGroup group(this->m_group);
    ValueType * old_array = m_array_data;
    const Integer global_size = group.size()*m_array_size;
    m_array_data = new ValueType[global_size];
    if (m_has_default_value)
      for(Integer i=0;i<global_size;++i) m_array_data[i] = m_default_value;
    for(ItemGroupRangeIterator i(group); i.hasNext(); ++i )
      {
        ValueType * oldData = BaseClass::operator[](i);
        ValueType * currentData = m_array_data + m_array_size * i.index();
        BaseClass::operator[](i) = currentData;
        if (oldData != NULL)
          {
            for(Integer j=0;j<m_array_size;++j)
              currentData[j] = oldData[j];
          }
      }
    delete[] old_array;
  }

  virtual void _compact(Int32ConstArrayView new_to_old_ids)
  {
    BaseClass::_compact(new_to_old_ids);
    _dataShifter();
  }

  virtual void _compact2(Int32ConstArrayView new_to_old_ids)
  {
    BaseClass::_compact2(new_to_old_ids);
    _dataShifter();
  }

  virtual void _copyItemsValues(Int32ConstArrayView source, Int32ConstArrayView destination)
  {
    const Integer size = source.size();
    for(Integer i=0;i<size;++i)
      {
        const Integer src_lid = source[i];
        const Integer dst_lid = destination[i];
        this->traceMng()->debug(Trace::Highest) << "Check source hasKey("<<src_lid<<"):"<<this->_hasKey(src_lid)
                                                << " target hasKey("<<dst_lid<<"):"<<this->_hasKey(dst_lid);
        typename BaseClass::Data * src_data = this->_lookupBucket(this->_hash(src_lid),src_lid);
        typename BaseClass::Data * dst_data = this->_lookupBucket(this->_hash(dst_lid),dst_lid);
        if (src_data == NULL or dst_data == NULL) continue;
        ValueType * oldData = src_data->m_value;
        ValueType * newData = dst_data->m_value;
        for(Integer j=0;j<m_array_size;++j)
          newData[j] = oldData[j];
      }
  }

private:
  void _dataShifter()
  {
    ItemGroup group(this->m_group);
    ValueType * old_array = m_array_data;
    const Integer global_size = group.size()*m_array_size;
    m_array_data = new ValueType[global_size];
    if (m_has_default_value)
      for(Integer i=0;i<global_size;++i) m_array_data[i] = m_default_value;
    for(Integer i=0;i<group.size();++i)
      {
        typename BaseClass::Data & hd = this->m_buffer[i];
        ValueType * oldData = hd.m_value;
        ValueType * currentData = m_array_data + m_array_size * i;
        hd.m_value = currentData;
        ARCANE_ASSERT( (oldData != NULL), ("Null data detected on compact"));
        for(Integer j=0;j<m_array_size;++j)
          currentData[j] = oldData[j];
      }
    delete[] old_array;
  }

  bool _hasDefaultValue() const { return m_has_default_value; }
  ValueType * _getDefaultValue() const { return NULL; }
};

/*---------------------------------------------------------------------------*/

/*! \brief Forme de tableau indéxé sur un groupe d'items à valeurs de type tableau
 *
 *  Permet d'indéxé un tableau par les items d'un groupe. Ceci évite
 *  des erreurs principalement en parallèle ou certains items ne sont
 *  pas contigus en localId (et évite le bug d'indexé un Array via les
 *  localId des items).
 *
 *  Il n'est possible d'accèder qu'à des items du groupe
 *  original. Retourne une exception si l'item demandé n'est pas
 *  référencé. L'accès en optimiser pour les ItemGroupRangeIterator
 *
 * \see ItemGroupMapT
 */
template <typename ItemKind, typename ValueType>
class ItemGroupMapArrayT : 
  public ItemGroupMapAbstractImplT<ValueType*>
{
public:
  typedef ArrayView<ValueType> ArrayType;
  typedef ConstArrayView<ValueType> ConstArrayType;

protected:
  typedef ItemGroupMapAbstractImplT<ValueType*> BaseClass;
  Integer m_array_size;
  ValueType * m_array_data;
  bool m_has_default_value;
  ValueType m_default_value;

public:
  //! Constructeur par défaut
  ItemGroupMapArrayT() 
    : BaseClass()
    , m_array_size(0)
    , m_array_data(NULL)
    , m_has_default_value(false)
  {
    ;
  }

  //! Constructeur à partir d'un groupe
  ItemGroupMapArrayT(const ItemGroupT<ItemKind> & group, 
                     const Integer array_size)
    : BaseClass()
    , m_array_data(NULL)
    , m_has_default_value(false)
  {
    init(group,array_size);
  }

  //! Constructeur à partir d'un groupe
  ItemGroupMapArrayT(const ItemGroupT<ItemKind> & group, 
                     const Integer array_size,
                     ValueType default_value) 
    : BaseClass()
    , m_array_data(NULL)
    , m_has_default_value(false)
  {
    setDefaultValue(default_value);
    init(group,array_size);
  }

  //! Destructeur
  virtual ~ItemGroupMapArrayT()
  {
    delete[] m_array_data;
  }
  
  //! Initialisation sur un nouveau groupe
  void init(const ItemGroupT<ItemKind> & group, const Integer array_size) 
  {
    const Integer old_global_size = m_array_size * this->group().size();
    m_array_size = array_size;
    BaseClass::init(group);
    const Integer global_size = group.size()*m_array_size;
    if ((old_global_size != global_size) or (m_array_data == NULL)) {
      delete[] m_array_data;
      m_array_data = new ValueType[global_size];
    }
    if (m_has_default_value)
      for(Integer i=0;i<global_size;++i) m_array_data[i] = m_default_value;

    for( ItemGroupRangeIteratorT<ItemKind> i(group); i.hasNext(); ++i )
      {
        ValueType * currentData = m_array_data + m_array_size * i.index();
        BaseClass::operator[](i) = currentData;
      }
  }

  //! Initialisation sans changement de taille des tableaux
  void init(const ItemGroupT<ItemKind> & group)
  {
    init(group,m_array_size);
  }

  //! Opérateur d'accès à partir d'un item
  /*! Retourne une exception si l'item n'est pas référencé */
  ArrayType operator[](const ItemKind & item) 
  {
    return ArrayType(m_array_size,BaseClass::operator[](item));
  }

  //! Opérateur d'accès à partir d'un ItemGroupRangeIteratorT
  /*! Retourne une exception si l'item n'est pas référencé */
  ArrayType operator[](const ItemGroupRangeIteratorT<ItemKind> & iter)
  {
    return ArrayType(m_array_size,BaseClass::operator[](iter));
  }

  /*! \brief Recherche la valeur correspondant à l'item associé à un énumérateur
   */
  inline ArrayType operator[](const ItemEnumeratorT<ItemKind> & iter)
  {
    return ArrayType(m_array_size,BaseClass::operator[](iter));
  }

  //! Opérateur d'accès en mode constant à partir d'un item
  /*! Retourne une exception si l'item n'est pas référencé */
  ConstArrayType operator[](const ItemKind & item) const
  {
    return ConstArrayType(m_array_size,BaseClass::operator[](item));
  }

  //! Opérateur d'accès en mode constant à partir d'un ItemGroupRangeIteratorT
  /*! Retourne une exception si l'item n'est pas référencé */
  ConstArrayType operator[](const ItemGroupRangeIteratorT<ItemKind> & iter) const
  {
    return ConstArrayType(m_array_size,BaseClass::operator[](iter));
  }

  /*! \brief Recherche la valeur correspondant à l'item associé à un énumérateur
   */
  inline const ConstArrayType operator[](const ItemEnumeratorT<ItemKind> & iter) const
  {
    return ConstArrayType(m_array_size,BaseClass::operator[](iter));
  }

  bool hasKey(const ItemKind & item) const
  {
    return BaseClass::hasKey(item);
  }

public:
  void setDefaultValue(const ValueType & default_value) { m_has_default_value = true; m_default_value = default_value; }

protected:
  virtual void _resizeFromGroup() {
    if (this->m_properties & ItemGroupMapAbstract::eResetOnResize ||
        this->m_properties & ItemGroupMapAbstract::eRecomputeOnResize)
      this->traceMng()->fatal() << "ItemGroupMap properties not yet implemented on arrays";

    BaseClass::_resizeFromGroup();
    ItemGroup group(this->m_group);
    ValueType * old_array = m_array_data;
    const Integer global_size = group.size()*m_array_size;
    m_array_data = new ValueType[global_size];
    if (m_has_default_value)
      for(Integer i=0;i<global_size;++i) m_array_data[i] = m_default_value;
    for(ItemGroupRangeIteratorT<ItemKind> i(group); i.hasNext(); ++i )
      {
        ValueType * oldData = BaseClass::operator[](i);
        ValueType * currentData = m_array_data + m_array_size * i.index();
        BaseClass::operator[](i) = currentData;
        if (oldData != NULL)
          {
            for(Integer j=0;j<m_array_size;++j)
              currentData[j] = oldData[j];
          }
      }
    delete[] old_array;
  }

  virtual void _compact(Int32ConstArrayView new_to_old_ids)
  {
    BaseClass::_compact(new_to_old_ids);
    _dataShifter();
  }

  virtual void _copyItemsValues(Int32ConstArrayView source, Int32ConstArrayView destination)
  {
    const Integer size = source.size();
    for(Integer i=0;i<size;++i)
      {
        const Integer src_lid = source[i];
        const Integer dst_lid = destination[i];
        this->traceMng()->debug(Trace::Highest) << "Check source hasKey("<<src_lid<<"):"<<this->_hasKey(src_lid)
                                                << " target hasKey("<<dst_lid<<"):"<<this->_hasKey(dst_lid);
        typename BaseClass::Data * src_data = this->_lookupBucket(this->_hash(src_lid),src_lid);
        typename BaseClass::Data * dst_data = this->_lookupBucket(this->_hash(dst_lid),dst_lid);
        if (src_data == NULL or dst_data == NULL) continue;
        ValueType * oldData = src_data->m_value;
        ValueType * newData = dst_data->m_value;
        for(Integer j=0;j<m_array_size;++j)
          newData[j] = oldData[j];
      }
  }

private:
  void _dataShifter()
  {
    ItemGroup group(this->m_group);
    ValueType * old_array = m_array_data;
    const Integer global_size = group.size()*m_array_size;
    m_array_data = new ValueType[global_size];
    if (m_has_default_value)
      for(Integer i=0;i<global_size;++i) m_array_data[i] = m_default_value;
    for(Integer i=0;i<group.size();++i)
      {
        typename BaseClass::Data & hd = this->m_buffer[i];
        ValueType * oldData = hd.m_value;
        ValueType * currentData = m_array_data + m_array_size * i;
        hd.m_value = currentData;
        ARCANE_ASSERT( (oldData != NULL), ("Null data detected on compact"));
        for(Integer j=0;j<m_array_size;++j)
          currentData[j] = oldData[j];
      }
    delete[] old_array;
  }

  bool _hasDefaultValue() const { return m_has_default_value; }
  ValueType * _getDefaultValue() const { return NULL; }
};

/*---------------------------------------------------------------------------*/

//! Classe vide
/*! Coute un octet en mémoire */
class Void { };
// inline std::ostream & operator<<(std::ostream & o, const Void & v) { return o; }

/*---------------------------------------------------------------------------*/

/*! ItemGroupSet s'utilise essentiellement avec hasKey vu que les données portées sont Void,
 *  L'implémentation spécialisée sans aucune données (encore moins que Void) a été désactivée
 *  afin de factoriser le code de resizeFromGroup et de _compact. Si besoin est, une implémentation
 *  spécifique est possible (en l'état utilise eResetOnResize pour optimiser le redimensionnement) */
class ItemGroupSet : protected ItemGroupMapAbstractImplT<Void> 
{
 public:
  ItemGroupSet()
    {
      m_properties |= eResetOnResize;
    }

  ItemGroupSet(const ItemGroup & group) : BaseClass(group) 
    {
      m_properties |= eResetOnResize;
    }

    void init(const ItemGroup & group)
    {
      BaseClass::init(group);
    }

    bool hasKey(const Item & item) const
    {
      return BaseClass::hasKey(item);
    }

 protected:
    typedef ItemGroupMapAbstractImplT<Void> BaseClass;

    bool _hasDefaultValue() const { return false; }
    Void _getDefaultValue() const { return Void(); }
};

/*---------------------------------------------------------------------------*/
#endif /* ITEMGROUP_USE_OBSERVERS */
/*---------------------------------------------------------------------------*/

#endif /* ITEMGROUPMAP_H */
