// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
/* Author : haeberlf at Fri Feb 20 11:24:08 2009
 * Generated by createNew
 */

#include "Mesh/GroupCreator/StandardGroupCreatorService.h"

#include "Utils/Utils.h"
#include "Utils/ItemTools.h"
#include "Utils/ItemGroupBuilder.h"
#include "Mesh/Geometry/IGeometryMng.h"

#include "Numerics/Expressions/IExpressionMng.h"
#include "Numerics/Expressions/IFunctionR3vR1.h"
#include "Numerics/Expressions/ExpressionBuilder/ExpressionBuilderR3vR1Core.h"

#include "Appli/IAppServiceMng.h"
#include "Mesh/GroupCreator/IGroupCreator.h"

using namespace Arcane;

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
StandardGroupCreatorService::
init()
{
  info() << __PRETTY_FUNCTION__;
  
  IAppServiceMng * app_service_mng = IAppServiceMng::instance(subDomain()->serviceMng());
  
  m_geometry_service = app_service_mng->find<IGeometryMng>(true);
  m_geometry_service->setPolicyTolerance(true);
  
  m_geometry_service->addItemGroupProperty(allCells(), IGeometryProperty::PCenter, IGeometryProperty::PVariable);
  m_geometry_service->addItemGroupProperty(allFaces(), IGeometryProperty::PCenter, IGeometryProperty::PVariable);
 
  m_geometry_service->update();
  
  // Acces  aux gestionnaires globaux et locaux pour constante ou autre expression (NULL sinon)
  m_expression_mng = app_service_mng->find<IExpressionMng>(true) ;
  
  m_local_expression_mng = NULL;

  m_function_parser.init(m_expression_mng, m_local_expression_mng, traceMng());

  m_scalar_eval= options()->scalarEval();
  
  m_filter_cell_tolerance = options()->filterCellTolerance();
  m_filter_face_tolerance = options()->filterFaceTolerance();

  // On crée des groupes vides car potentiellement utilisés dans 
  // d'autres services (Par exemple les conditions limites)
  // On a donc besoin qu'ils existent afin d'y faire porter 
  // des propriétés géométriques
  
  // Create empty cell groups
  for(int i_cell_group = 0; i_cell_group < options()->cellgroup.size(); ++i_cell_group)
    {
      const String cell_group_name = options()->cellgroup[i_cell_group]->name();
      
      info() << "Create empty cell group named " << cell_group_name;
      
      ItemGroupBuilder<Cell> cell_group_builder(mesh(), cell_group_name);
      
      cell_group_builder.buildGroup();
    }
  
  // Create empty face groups
  for(int i_face_group = 0; i_face_group < options()->facegroup.size(); ++i_face_group)
    {
      const String face_group_name = options()->facegroup[i_face_group]->name();
      
      info() << "Create empty face group named " << face_group_name;
      
      ItemGroupBuilder<Face> face_group_builder(mesh(), face_group_name);
      
      face_group_builder.buildGroup();
    }
}

/*---------------------------------------------------------------------------*/

void
StandardGroupCreatorService::
apply()
{
  info() << "Apply Group Creator Service";
  
  m_timer_groupcreator_create.start();
  
  createCellGroups();
  createFaceGroups();
  
  m_timer_groupcreator_create.stop();
  
  info() << "Group Creator Service Done";

  reportTimer();
}

/*---------------------------------------------------------------------------*/

void
StandardGroupCreatorService::
reportTimer()
{
  info() << "--------------------";
  info() << "Timer : " << m_timer_groupcreator_create.totalTime()   << " - Group Creator Apply" ;
  info() << "--------------------";
  info() << "Timer : " << m_timer_groupcreator_filter.totalTime()    << " - Group Creator Filter Items" ;
  info() << "Timer : " << m_timer_groupcreator_add.totalTime()      << " - Group Creator Select and Add Items" ;
  info() << "Timer : " << m_timer_groupcreator_build.totalTime() << " - Group Creator Build Item Group" ;
  info() << "--------------------";
}

/*---------------------------------------------------------------------------*/

void
StandardGroupCreatorService::
createCellGroups()
{
  info() << "Group Creator Service create Cell Groups";

  const IGeometryMng::Real3Variable & cell_centers = m_geometry_service->getReal3VariableProperty(allCells(), IGeometryProperty::PCenter);

  for(int cellgroup_nbr=0; cellgroup_nbr<options()->cellgroup.size(); cellgroup_nbr++)
    {
      String cellgroup_name = options()->cellgroup[cellgroup_nbr]->name();
      info() << "Found Cellgroup number " << cellgroup_nbr << " with name " << cellgroup_name;
      ItemGroupBuilder<Cell> cell_group_builder(mesh(), cellgroup_name);

      info() << "  Read Filter Expression";
      String filter_expression = options()->cellgroup[cellgroup_nbr]->filter();
      filter_expression = "(x,y,z)-> " + filter_expression;
      info() << "  expression=" << filter_expression;

      bool filter_test = options()->cellgroup[cellgroup_nbr]->filterTest();
      info() << "  filter_test=" << filter_test;

      info() << "  Parse expression";
      m_function_parser.parseString( filter_expression) ; //"(x,y,z)-> x+y*-sin(z)" );

      info() << "  Build Function filter";
      ExpressionBuilderR3vR1Core filter = ExpressionBuilderR3vR1Core(&m_function_parser);

      for(int area_nbr=0; area_nbr<options()->cellgroup[cellgroup_nbr]->area.size(); area_nbr++)
        {
          String area_name = options()->cellgroup[cellgroup_nbr]->area[area_nbr];
          info() << "  Found area number" << area_nbr << " with name " << area_name;

          // Check if area_name exists as a cellgroup otherwise return empty cellgroup
          CellGroup area_cellgroup  = mesh()->cellFamily()->findGroup(area_name,false);
          if (area_cellgroup.null())
            fatal() << "Undefined area with name " << area_name ;

          m_timer_groupcreator_filter.start();

          RealArray cell_filter_value;
          
          cell_filter_value.resize(area_cellgroup.size());

          if(m_scalar_eval)
            {
              info() << "build cell group filter ";
              Integer index = 0;
              ENUMERATE_CELL(iCell,area_cellgroup)
                {
                  const Real3 cell_center = cell_centers[iCell];
                  
                  filter.eval(cell_center.x,cell_center.y,cell_center.z,cell_filter_value[index++]);
                }
            }
          else
            {
              info() << "build Cell filter array";
              // recopy
              // to be removed when IFunctionR3vR1 interCell implements eval(Real3,Real) method
              Array<Real> x(area_cellgroup.size());
              Array<Real> y(area_cellgroup.size());
              Array<Real> z(area_cellgroup.size());
              {
                Integer iData = 0;
                ENUMERATE_CELL(iCell, area_cellgroup)
                  {
                    const Cell& cell = *iCell;
                    const Real3& center = cell_centers[cell];

                    x[iData] = center.x;
                    y[iData] = center.y;
                    z[iData] = center.z;
                    iData++;
                  }
              }

              // Evaluate analytic solution
              filter.eval(x, y, z, cell_filter_value);
            }

          m_timer_groupcreator_filter.stop();

          //------------

          info() << "select and add cells ";
          m_timer_groupcreator_add.start();
          Integer index = 0;
          ENUMERATE_CELL(iCell,area_cellgroup)
            {
              const Real filter_result = cell_filter_value[index++];
              if ( (filter_result > m_filter_cell_tolerance) == filter_test )
                cell_group_builder.add(*iCell);
            }
          m_timer_groupcreator_add.stop();
        }

      info() << "build cell group ";
      m_timer_groupcreator_build.start();
      CellGroup cellgroup = cell_group_builder.buildGroup();
      m_timer_groupcreator_build.stop();

      info() << "New group created with name " << cellgroup_name << " with " << cellgroup.size() << " elements.";
    }
}

/*---------------------------------------------------------------------------*/

void
StandardGroupCreatorService::
createFaceGroups()
{
  info() << "Group Creator Service Create Face Groups";

  const IGeometryMng::Real3Variable & face_centers = m_geometry_service->getReal3VariableProperty(allFaces(), IGeometryProperty::PCenter);

  for(int facegroup_nbr=0; facegroup_nbr<options()->facegroup.size(); facegroup_nbr++)
    {

      String facegroup_name = options()->facegroup[facegroup_nbr]->name();
      info() << "Found Facegroup number " << facegroup_nbr << " with name " << facegroup_name;
      ItemGroupBuilder<Face> face_group_builder(mesh(), facegroup_name);

      info() << "  Read Filter Expression";
      String filter_expression = options()->facegroup[facegroup_nbr]->filter();
      filter_expression = "(x,y,z)-> " + filter_expression;
      info() << "  expression=" << filter_expression;

      bool filter_test = options()->facegroup[facegroup_nbr]->filterTest();
      info() << "  filter_test=" << filter_test;

      info() << "  Parse expression";
      m_function_parser.parseString( filter_expression) ; //"(x,y,z)-> 0." );

      info() << "  Build Function filter";
      ExpressionBuilderR3vR1Core filter = ExpressionBuilderR3vR1Core(&m_function_parser);

      for(int area_nbr=0; area_nbr<options()->facegroup[facegroup_nbr]->area.size(); area_nbr++)
        {
          String area_name = options()->facegroup[facegroup_nbr]->area[area_nbr];
          info() << "  Found area number" << area_nbr << " with name " << area_name;

          FaceGroup area_facegroup;
          
          // Check if area_name exists as a cellgroup otherwise return empty cellgroup
          if(area_name=="GC_allBoundaryFaces")
            {
              area_facegroup = outerFaces().own();
            }
          else
            {
              area_facegroup  = mesh()->faceFamily()->findGroup(area_name,false);
              if (area_facegroup.null())
                fatal() << "Undefined area with name " << area_name ;
            }
          
          // On parcourt le groupe toujours de la même manière, on peut donc utiliser
          // une structure de type Array
          // NB : Il n'est pas possible d'utiliser un ItemGroupMap car le groupe est own().
          // On peut contourner cela mais le coût peut être élevé
          RealArray face_filter_value;
          
          face_filter_value.resize(area_facegroup.size());
          
          m_timer_groupcreator_filter.start();
          if(m_scalar_eval)
            {
              info() << "build face filter";
              Integer index = 0;
              ENUMERATE_FACE(iFace,area_facegroup)
                {                  
                  const Real3 face_center = face_centers[iFace];
                                    
                  filter.eval(face_center.x,face_center.y,face_center.z,face_filter_value[index++]);
                }
            }

          else
            {
              info() << "build face filter array";
              // recopy
              // to be removed when IFunctionR3vR1 interface implements eval(Real3,Real) method
              Array<Real> x(area_facegroup.size());
              Array<Real> y(area_facegroup.size());
              Array<Real> z(area_facegroup.size());
              {
                Integer iData = 0;
                ENUMERATE_FACE(iFace, area_facegroup)
                  {
                    const Real3& center = face_centers[iFace];

                    x[iData] = center.x;
                    y[iData] = center.y;
                    z[iData] = center.z;
                    iData++;
                  }
              }

              // Evaluate analytic solution
              filter.eval(x, y, z, face_filter_value);
            }

          m_timer_groupcreator_filter.stop();

          //----------
          
          info() << "select and add faces";
          m_timer_groupcreator_add.start();
          Integer index = 0;
          ENUMERATE_FACE(iFace,area_facegroup)
            {
              const Real filter_result = face_filter_value[index++];
              if( (filter_result > m_filter_face_tolerance) == filter_test )
                face_group_builder.add(*iFace);
            }
          m_timer_groupcreator_add.stop();
        }

      info() << "build face group";
      m_timer_groupcreator_build.start();
      FaceGroup facegroup = face_group_builder.buildGroup();
      m_timer_groupcreator_build.stop();
      info() << "New group created with name " << facegroup_name << " with " << facegroup.size() << " elements.";
    }

}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

ARCANE_REGISTER_SERVICE_STANDARDGROUPCREATOR(StandardGroupCreator,StandardGroupCreatorService);
