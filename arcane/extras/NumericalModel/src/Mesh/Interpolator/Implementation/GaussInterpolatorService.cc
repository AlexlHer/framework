// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
#include "Mesh/Interpolator/Implementation/GaussInterpolatorService.h"
/* Author : dipietrd at Thu May 29 14:06:52 2008
 * Generated by createNew
 */

#include "Mesh/Geometry/IGeometryMng.h"

using namespace Arcane;

////////////////////////////////////////////////////////////

void GaussInterpolatorService::init() {
  m_app_service_mng = IAppServiceMng::instance(subDomain()->serviceMng());
}

void GaussInterpolatorService::prepare() {
  // Retrieve relevant geometrical properties
  IGeometryMng* geometry_service = m_app_service_mng->find<IGeometryMng>(true);

  geometry_service->addItemGroupProperty(ownCells(), IGeometryProperty::PVolume,IGeometryProperty::PVariable);
  geometry_service->addItemGroupProperty(allFaces(), IGeometryProperty::PCenter,IGeometryProperty::PVariable);
  geometry_service->addItemGroupProperty(ownCells(), IGeometryProperty::PMeasure,IGeometryProperty::PVariable);
  
//  geometry_service->update();
}

////////////////////////////////////////////////////////////

void GaussInterpolatorService::setSourceField(const MeshVariableRef* source) {
  try {
    m_source = dynamic_cast<const SourceType*>(source);
  }
  catch(std::bad_cast) {
    error() << "Source field of incorrect type";
  }
}

////////////////////////////////////////////////////////////

void GaussInterpolatorService::setTargetField(MeshVariableRef* target) {
  try {
    m_target = dynamic_cast<TargetType*>(target);
  }
  catch(std::bad_cast) {
    error() << "Target field of incorrect type";
  }
}

////////////////////////////////////////////////////////////

void GaussInterpolatorService::interpolate() {
  // Retrieve relevant geometrical properties
  IGeometryMng* geometry_service = m_app_service_mng->find<IGeometryMng>(true);

  const IGeometryMng::Real3Variable& cell_centers =
    geometry_service->getReal3VariableProperty(ownCells(), IGeometryProperty::PCenter);
  const IGeometryMng::Real3Variable& face_centers = 
    geometry_service->getReal3VariableProperty(allFaces(), IGeometryProperty::PCenter);

  const IGeometryMng::RealVariable& cell_measures =
    geometry_service->getRealVariableProperty(ownCells(), IGeometryProperty::PMeasure);
  // const IGeometryMng::RealVariable& face_measures =
  //  geometry_service->getRealVariableProperty(allFaces(), IGeometryProperty::PMeasure);

  // Interpolate
  ENUMERATE_CELL(icell, ownCells()) {
    const Cell T = *icell;
    Real3& target_T = (*m_target)[T];

    const Real3& xT = cell_centers[T];
    Real meas_T = cell_measures[T];

    ENUMERATE_FACE(iface, T.faces()) {
      const Face F = *iface;
      
      Real alpha = (T == F.backCell() ? 1. : -1.);

      const Real3& xF = face_centers[F];
      // Real meas_F = face_measures[F];
      Real source_F = (*m_source)[F];

#warning "CHECK: Assuming that source field contains integrals on faces rather than values"
      target_T += (alpha / meas_T) * source_F * (xF - xT);
    }
  }
}

ARCANE_REGISTER_SERVICE_GAUSSINTERPOLATOR(GaussInterpolator,GaussInterpolatorService);
