// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
#include "Mesh/Geometry/Impl/GeometryServiceBase.h"
/* Author : havep at Thu Apr  3 09:09:09 2008
 * Generated by createNew
 */

#include <arcane/IMesh.h>
using namespace Arcane;

#include <arcane/IItemOperationByBasicType.h>
#include <arcane/IItemFamily.h>
#include <arcane/ArcaneVersion.h>
#include <arcane/ItemVectorView.h>

#include <set>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

GeometryServiceBase::
GeometryServiceBase()
{
  m_suffix = String("By")+(unsigned long)(this);
  m_changed_property = true; // par défaut pour induire directement une erreur si update non appelé
  m_policy_tolerance = eUndef;
}

GeometryServiceBase::
~GeometryServiceBase()
{
  ;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void 
GeometryServiceBase::
addItemGroupProperty(ItemGroup group, Integer property)
{
  const Integer storage = IGeometryProperty::PVariable|IGeometryProperty::PItemGroupMap;
  Trace::Setter setter(traceMng(),className());
  if (m_policy_tolerance == eUndef)
    traceMng()->fatal() << "IGeometryMng::addItemGroupProperty called without defined policy tolerance";
  if (m_policy_tolerance == eLazy)
    traceMng()->error() << "Try to register property without storage info : this error will become fatal soon";
  else
    traceMng()->fatal() << "Try to register property without storage info";

  m_changed_property = true;
  ItemGroupGeometryProperty & properties = m_group_property_map[group.internal()];
  properties.defined |= property;
  Integer current_property = 1;
  while (property) {
    if (property & current_property) {
      properties.storages[static_cast<IGeometryProperty::eProperty>(current_property)].storageType |= storage;
      traceMng()->debug() << "Add geometric property [" << IGeometryProperty::name(static_cast<IGeometryProperty::eProperty>(current_property)) << "] on group " << group.name();
    }
    property &= ~current_property;
    current_property <<= 1;
  }
}

void 
GeometryServiceBase::
addItemGroupProperty(ItemGroup group, Integer property, Integer storage)
{
  m_changed_property = true;
  ItemGroupGeometryProperty & properties = m_group_property_map[group.internal()];
  properties.defined |= property;
  Integer current_property = 1;
  while (property) {
    if (property & current_property) {
      properties.storages[static_cast<IGeometryProperty::eProperty>(current_property)].storageType |= storage;
      traceMng()->debug() << "Add geometric property [" << IGeometryProperty::name(static_cast<IGeometryProperty::eProperty>(current_property)) << "] on group " << group.name();
    }
    property &= ~current_property;
    current_property <<= 1;
  }
}

void 
GeometryServiceBase::
addItemGroupProperty(ItemGroup group, IGeometryProperty::eProperty property, RealVariable var)
{
  m_changed_property = true;
  ARCANE_ASSERT((IGeometryProperty::isScalar(property)),("Scalar property expected"));
  ItemGroupGeometryProperty & properties = m_group_property_map[group.internal()];
  ItemGroupGeometryProperty::StorageInfo & storage = properties.storages[property];
  if (storage.realVar) {
    if (storage.realVar->name() != var.name())
      traceMng()->fatal() << "Geometric property [" << IGeometryProperty::name(property) << "] storage already defined on group " << group.name() << " with variable " << storage.realVar->name();
    ARCANE_ASSERT((properties.defined & property),("Unconsistent state with undefined property with defined variable"));
    return;
  }
  properties.defined |= property;
  storage.realVar.reset(new RealVariable(var));
  storage.storageType |= IGeometryProperty::PVariable;
  storage.externStorage |= IGeometryProperty::PVariable;  
}

void 
GeometryServiceBase::
addItemGroupProperty(ItemGroup group, IGeometryProperty::eProperty property, Real3Variable var)
{
  m_changed_property = true;
  ARCANE_ASSERT((IGeometryProperty::isVectorial(property)),("Vectorial property expected"));
  ItemGroupGeometryProperty & properties = m_group_property_map[group.internal()];
  ItemGroupGeometryProperty::StorageInfo & storage = properties.storages[property];
  if (storage.real3Var) {
    if (storage.real3Var->name() != var.name())
      traceMng()->fatal() << "Geometric property [" << IGeometryProperty::name(property) << "] storage already defined on group " << group.name() << " with variable " << storage.real3Var->name();
    ARCANE_ASSERT((properties.defined & property),("Unconsistent state with undefined property with defined variable"));
    return;
  }
  properties.defined |= property;
  storage.real3Var.reset(new Real3Variable(var));
  storage.storageType |= IGeometryProperty::PVariable;
  storage.externStorage |= IGeometryProperty::PVariable;  
}

Integer 
GeometryServiceBase::
getItemGroupProperty(ItemGroup group)
{
  PropertyMap::const_iterator iprop = m_group_property_map.find(group.internal());
  if (iprop == m_group_property_map.end()) return IGeometryProperty::PNone;
  return iprop->second.defined;
}

bool 
GeometryServiceBase::
hasItemGroupProperty(ItemGroup group, Integer property)
{
  return (getItemGroupProperty(group) & property) == property;
}

Integer
GeometryServiceBase::
getItemGroupPropertyStorage(ItemGroup group, IGeometryProperty::eProperty property)
{
  PropertyMap::const_iterator iprop = m_group_property_map.find(group.internal());
  if (iprop == m_group_property_map.end()) return IGeometryProperty::PNoStorage;
  return iprop->second.getStorage(property);
}

/*---------------------------------------------------------------------------*/

const IGeometryMng::RealVariable & 
GeometryServiceBase::
getRealVariableProperty(ItemGroup group, IGeometryProperty::eProperty property)
{
  Trace::Setter setter(traceMng(),className());
  if (m_policy_tolerance == eUndef)
    traceMng()->fatal() << "IGeometryMng::update called without defined policy tolerance";
  if (m_changed_property)
    if (m_policy_tolerance == eLazy)
      traceMng()->error() << "Property requested without validation with update() : this error will become fatal soon";
    else
      traceMng()->fatal() << "Property requested without validation with update()";

  if (not IGeometryProperty::isScalar(property))
    traceMng()->fatal() << "Non scalar property requested by scalar interface";
  ItemGroupGeometryProperty::StorageInfo & storage = _checkItemGroupProperty(group.internal(),property,IGeometryProperty::PVariable);  
  boost::shared_ptr<RealVariable> & pvar = storage.realVar;
  if (not pvar)
    throw FatalErrorException(A_FUNCINFO,"Unexpected missing scalar field");
  storage.usageVarCount++;
  return *pvar;
}

const IGeometryMng::Real3Variable & 
GeometryServiceBase::
getReal3VariableProperty(ItemGroup group, IGeometryProperty::eProperty property)
{
  Trace::Setter setter(traceMng(),className());
  if (m_policy_tolerance == eUndef)
    traceMng()->fatal() << "IGeometryMng::update called without defined policy tolerance";
  if (m_changed_property)
    if (m_policy_tolerance == eLazy)
      traceMng()->error() << "Property requested without validation with update() : this error will become fatal soon";
    else
      traceMng()->fatal() << "Property requested without validation with update()";

  if (not IGeometryProperty::isVectorial(property)) 
    traceMng()->fatal() << "Non vectorial property requested by vectorial interface";  
  ItemGroupGeometryProperty::StorageInfo & storage = _checkItemGroupProperty(group.internal(),property,IGeometryProperty::PVariable);
  boost::shared_ptr<Real3Variable> & pvar = storage.real3Var;
  if (not pvar)
    throw FatalErrorException(A_FUNCINFO,"Unexpected missing vectorial field");
  storage.usageVarCount++;
  return *pvar;
}

/*---------------------------------------------------------------------------*/

const IGeometryMng::RealGroupMap & 
GeometryServiceBase::
getRealGroupMapProperty(ItemGroup group, IGeometryProperty::eProperty property)
{
  Trace::Setter setter(traceMng(),className());
  if (m_policy_tolerance == eUndef)
    traceMng()->fatal() << "IGeometryMng::update called without defined policy tolerance";
  if (m_changed_property)
    if (m_policy_tolerance == eLazy)
      traceMng()->error() << "Property requested without validation with update() : this error will become fatal soon";
    else
      traceMng()->fatal() << "Property requested without validation with update()";

  if (not IGeometryProperty::isScalar(property)) 
    traceMng()->fatal() << "Non scalar property requested by scalar interface";  
  ItemGroupGeometryProperty::StorageInfo & storage = _checkItemGroupProperty(group.internal(),property,IGeometryProperty::PItemGroupMap);
  boost::shared_ptr<RealGroupMap> & pmap = storage.realMap;
  if (not pmap)
    throw FatalErrorException(A_FUNCINFO,"Unexpected missing scalar field");
  storage.usageMapCount++;
  return *pmap;
}

const IGeometryMng::Real3GroupMap & 
GeometryServiceBase::
getReal3GroupMapProperty(ItemGroup group, IGeometryProperty::eProperty property)
{
  Trace::Setter setter(traceMng(),className());
  if (m_policy_tolerance == eUndef)
    traceMng()->fatal() << "IGeometryMng::update called without defined policy tolerance";
  if (m_changed_property)
    if (m_policy_tolerance == eLazy)
      traceMng()->error() << "Property requested without validation with update() : this error will become fatal soon";
    else
      traceMng()->fatal() << "Property requested without validation with update()";

  if (not IGeometryProperty::isVectorial(property)) 
    traceMng()->fatal() << "Non vectorial property requested by vectorial interface";  
  ItemGroupGeometryProperty::StorageInfo & storage = _checkItemGroupProperty(group.internal(),property,IGeometryProperty::PItemGroupMap);
  boost::shared_ptr<Real3GroupMap> & pmap = storage.real3Map;
  if (not pmap)
    throw FatalErrorException(A_FUNCINFO,"Unexpected missing vectorial field");
  storage.usageMapCount++;
  return *pmap;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void 
GeometryServiceBase::
update(IGeometryPolicy * policy)
{
  Trace::Setter setter(traceMng(),className());
  if (m_policy_tolerance == eUndef)
    traceMng()->fatal() << "IGeometryMng::update called without defined policy tolerance";
  if (policy == NULL)
    if (m_policy_tolerance == eLazy)
      traceMng()->error() << "IGeometryMng::update called with illegal policy : this error will become fatal soon";
    else
      traceMng()->fatal() << "IGeometryMng::update called with illegal policy";

  _checkItemGroupUsage();
  _resetComputeFlags();

  IMesh * mesh = this->mesh();
  // 
  const eItemKind all_kinds[] = { IK_Face, IK_Cell };
  const Integer all_kind_size = sizeof(all_kinds) / sizeof(eItemKind);

  for(Integer ikind=0;ikind<all_kind_size;++ikind) {
    const eItemKind current_kind = all_kinds[ikind];
    IItemFamily * family = mesh->itemFamily(current_kind);
    ItemGroup allItemGroup = family->allItems();

    if (m_group_property_map.find(allItemGroup.internal()) != m_group_property_map.end()) {
      // Delegate all geometric properties already planned for allItems
      ItemGroupGeometryProperty & all_group_property = m_group_property_map[allItemGroup.internal()];
      update(allItemGroup);
    
      for(PropertyMap::iterator igroup = m_group_property_map.begin(); igroup != m_group_property_map.end(); ++igroup)
        {
          ItemGroup group(igroup->first);
          if (group.itemKind() == current_kind) {
            ItemGroupGeometryProperty & group_property = igroup->second;
            for(ItemGroupGeometryProperty::StorageInfos::const_iterator iprop = group_property.storages.begin();
                iprop != group_property.storages.end(); ++iprop)
              {
                const IGeometryProperty::eProperty property = iprop->first;
                ItemGroupGeometryProperty::StorageInfo & storage = group_property.storages[property];

                if (property & all_group_property.defined) // propriétés communes avec allItemGroup
                  {
                    // Is a scalar property
                    if (IGeometryProperty::isScalar(property)) 
                      {
#ifdef __GNUG__
#warning "BUG: fails when ItemGroupMap storage only on allItems group"
#endif
                        RealVariable & var = *all_group_property.storages[property].realVar;
                        
                        // Need Variable storage for that property ?
                        if (storage.storageType & IGeometryProperty::PVariable)
                          {
                            if (storage.externStorage & IGeometryProperty::PVariable)
                              {
                                RealVariable & lvar = *storage.realVar;
                                ENUMERATE_ITEM(iitem,group)
                                  {
                                    lvar[iitem] = var[iitem];
                                  }
                              }
                            else
                              {
                                boost::shared_ptr<RealVariable> & lvar = storage.realVar;
                                if (lvar)
                                  {
                                    if (lvar->variable() != var.variable())
                                      {
                                        // change reference to allItems container
                                        lvar.reset(new RealVariable(var));
                                      }
                                    // else nothing to copy; already well referenced
                                  }
                                else
                                  {
                                    // new reference on allItems container
                                    lvar.reset(new RealVariable(var));
                                  }
                              }
                          }
                        
                        // Need ItemGroupMap storage for that property ?
                        if (storage.storageType & IGeometryProperty::PItemGroupMap) {
                          ARCANE_ASSERT(((storage.externStorage & IGeometryProperty::PItemGroupMap) == 0),("Unexpected extern ItemGroupMap storage"));
                          if (IGeometryProperty::isScalar(property))
                            {
                              boost::shared_ptr<RealGroupMap> & lvar = storage.realMap;
                              if (not lvar) {
                                lvar.reset(new RealGroupMap(group));
                                traceMng()->debug() << "Building Map " << lvar->name();
                              }
                              ENUMERATE_ITEM(iitem,group)
                                {
                                  (*lvar)[iitem] = var[iitem];
                                }
                            }
                        }
                        group_property.computed |= property;
                        group_property.delegated |= property;
                      }
                    else
                      {
                        ARCANE_ASSERT((IGeometryProperty::isVectorial(property)),("Vectorial property expected"));
                        Real3Variable & var = *all_group_property.storages[property].real3Var;
                        
                        // Need Variable storage for that property ?
                        if (storage.storageType & IGeometryProperty::PVariable)
                          {
                            if (storage.externStorage & IGeometryProperty::PVariable)
                              {
                                Real3Variable & lvar = *storage.real3Var;
                                ENUMERATE_ITEM(iitem,group)
                                  {
                                    lvar[iitem] = var[iitem];
                                  }
                              }
                            else
                              {
                                boost::shared_ptr<Real3Variable> & lvar = storage.real3Var;
                                if (lvar)
                                  {
                                    if (lvar->variable() != var.variable())
                                      {
                                        // change reference to allItems container
                                        lvar.reset(new Real3Variable(var));
                                      }
                                    // else nothing to copy; already well referenced
                                  }
                                else
                                  {
                                    // new reference on allItems container
                                    lvar.reset(new Real3Variable(var));
                                  }
                              }
                          }
                        
                        // Need ItemGroupMap storage for that property ?
                        if (storage.storageType & IGeometryProperty::PItemGroupMap) {
                          ARCANE_ASSERT(((storage.externStorage & IGeometryProperty::PItemGroupMap) == 0),("Unexpected extern ItemGroupMap storage"));
                          {
                            boost::shared_ptr<Real3GroupMap> & lvar = storage.real3Map;
                            if (not lvar) {
                              lvar.reset(new Real3GroupMap(group));
                              traceMng()->debug() << "Building Map " << lvar->name();
                            }
                            ENUMERATE_ITEM(iitem,group)
                              {
                                (*lvar)[iitem] = var[iitem];
                              }
                          }
                        }
                        group_property.computed |= property;
                        group_property.delegated |= property;
                      }
                  }
              }
          }
        }
    }
  }

  // Mise à jour des autres propriétés
  for(PropertyMap::iterator iprop = m_group_property_map.begin(); iprop != m_group_property_map.end(); ++iprop) 
    {
      update(iprop->first);
    }
  m_changed_property = false;
}

void 
GeometryServiceBase::
reset()
{
  for(PropertyMap::iterator iprop = m_group_property_map.begin(); iprop != m_group_property_map.end(); ++iprop) 
    {
      reset(iprop->first);
    }
}
 
void 
GeometryServiceBase::
setPolicyTolerance(bool tolerance)
{
  if (tolerance)
    m_policy_tolerance = eLazy;
  else
    m_policy_tolerance = eStrict;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

ItemGroupGeometryProperty::StorageInfo & 
GeometryServiceBase::_checkItemGroupProperty(ItemGroupImpl* group,
                                             IGeometryProperty::eProperty property,
                                             IGeometryProperty::eStorage storage) 
{
  PropertyMap::iterator iprop = m_group_property_map.find(group);
  if (iprop == m_group_property_map.end())
    traceMng()->fatal() << "Non declare group " << group->name();
  ItemGroupGeometryProperty & properties = iprop->second;
  if ((properties.defined & property) != property)
    traceMng()->fatal() << "Non available property [" << IGeometryProperty::name(property) << "] requested from group " << group->name();
  ItemGroupGeometryProperty::StorageInfo & storages = properties.storages[property];
  if ((storages.storageType & storage) != storage)
    traceMng()->fatal() << "Non available storage [" << IGeometryProperty::name(storage) << "] requested for property " << IGeometryProperty::name(property) << " on group " << group->name();
  return storages;
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
GeometryServiceBase::_resetComputeFlags()
{
  for(PropertyMap::iterator igroup = m_group_property_map.begin(); igroup != m_group_property_map.end(); ++igroup)
    {
      ItemGroupGeometryProperty & group_property = igroup->second;
      group_property.resetFlags();
    }
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void
GeometryServiceBase::_checkItemGroupUsage()
{
  // Control that all extern storage are not shared !
  typedef std::map<const IVariable *,std::pair<ItemGroupImpl*,IGeometryProperty::eProperty> > ExternVariables;
  ExternVariables extern_variables;
  typedef std::map<const ItemGroupMapAbstract *,std::pair<ItemGroupImpl*,IGeometryProperty::eProperty> > ExternMaps;
  ExternMaps extern_maps;

  for(PropertyMap::iterator igroup = m_group_property_map.begin(); igroup != m_group_property_map.end(); ++igroup)
    {
      ItemGroupGeometryProperty & group_property = igroup->second;
      for(ItemGroupGeometryProperty::StorageInfos::const_iterator i = group_property.storages.begin();
          i != group_property.storages.end(); ++i)
        {
          const IGeometryProperty::eProperty property = i->first;
          const ItemGroupGeometryProperty::StorageInfo & info = i->second;
          if (info.usageVarCount == 0 and (info.realVar or info.real3Var) and not (info.externStorage & IGeometryProperty::PVariable) )
            traceMng()->warning() << "Geometric property " << IGeometryProperty::name(property) << " on group " << igroup->first->name() << " with Variable storage never used since last update";
          if (info.usageMapCount == 0 and (info.realMap or info.real3Map) and not (info.externStorage & IGeometryProperty::PVariable) )
            traceMng()->warning() << "Geometric property " << IGeometryProperty::name(property) << " on group " << igroup->first->name() << " with Map storage never used since last update";

          // Check non shared extern Variable storage
          if (info.realVar or info.real3Var and (info.externStorage & IGeometryProperty::PVariable)) {
            IVariable * check_variable = NULL;
            if (info.realVar) {
              check_variable = info.realVar->variable();
            }
            if (info.real3Var) {
              ARCANE_ASSERT((check_variable==NULL),("Inconsistent real/real3 storage"));
              check_variable = info.real3Var->variable();
            }
            ExternVariables::const_iterator finder = extern_variables.find(check_variable);
            if (finder != extern_variables.end()) {
              traceMng()->warning() << "Geometric property " << IGeometryProperty::name(property) << " on group " << igroup->first->name() << " shares extern Variable " << finder->first->name() << " with property " << IGeometryProperty::name(finder->second.second) << " on group " << finder->second.first->name();
            } else {
              extern_variables[check_variable] = std::make_pair(igroup->first,property);
            }
          }

          // Check non shared extern ItemGroupMap storage
          if (info.realMap or info.real3Map and (info.externStorage & IGeometryProperty::PItemGroupMap)) {
            ItemGroupMapAbstract * check_variable = NULL;
            if (info.realMap) {
              check_variable = info.realMap.get();
            }
            if (info.real3Map) {
              ARCANE_ASSERT((check_variable==NULL),("Inconsistent real/real3 storage"));
              check_variable = info.real3Map.get();
            }
            ExternMaps::const_iterator finder = extern_maps.find(check_variable);
            if (finder != extern_maps.end()) {
              traceMng()->warning() << "Geometric property " << IGeometryProperty::name(property) << " on group " << igroup->first->name() << " shares extern ItemGroupMap " << finder->first->name() << " with property " << IGeometryProperty::name(finder->second.second) << " on group " << finder->second.first->name();
            } else {
              extern_maps[check_variable] = std::make_pair(igroup->first,property);
            }
          }
        }
    }
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
