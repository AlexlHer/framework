// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
#ifndef ARCGEOSIM_GEOMETRY_IGEOMETRYMNG_H
#define ARCGEOSIM_GEOMETRY_IGEOMETRYMNG_H
/* Author : havep at Wed Nov 14 13:41:31 2007
 * Generated by createNew
 */

#include <arcane/ItemGroup.h>
#include <arcane/ArcaneTypes.h>
#include <arcane/MeshVariableRef.h>
#include <arcane/VariableTypedef.h>
#include <arcane/utils/String.h>
#include <Utils/ItemGroupMap.h>
using namespace Arcane;

//! Interface for local geometry computations
class IGeometry;

//! Future interface de la gestion d'écriture de la géométrie;
class IGeometryPolicy { };

//! Geometric properties
/*! Some of them are contextual. 
 *  For example, the PMeasure of a 3D cell is its PVolume.
 * 
 *  Technical notes: A external container given by the user cannot
 *  be used for anything except the given property.
 *  An internal ItemGroupMap cannot be allocated for a group different 
 *  of the group wished by the used.
 */
struct IGeometryProperty 
{
  enum eProperty
    {
      PNone               = 0,
      PMeasure            = (1 << 0),
      PLength             = (1 << 1),
      PArea               = (1 << 2),
      PVolume             = (1 << 3),
      PCenter             = (1 << 4),
      PNormal             = (1 << 5),
      PVolumeSurfaceRatio = (1 << 6),
      PEnd                = (1 << 7) //! Marqueur de dernier type
    };

  enum eStorage
    {
      PNoStorage    = 0,
      PVariable     = (1 << 0),
      PItemGroupMap = (1 << 1)
    };

  static bool isScalar(const eProperty p) 
  {
    return (p & (PMeasure|PLength|PArea|PVolume|PVolumeSurfaceRatio)) != 0;
  }

  static bool isVectorial(const eProperty p) 
  {
    return (p & (PCenter|PNormal)) != 0;
  }

  class Enumerator
  {
  public:
    Enumerator() : m_state(1) { }
    eProperty operator*() const { return (eProperty)m_state; }
    void operator++() { m_state <<= 1; }
    bool end() const { return m_state == PEnd; }
    private:
      Integer m_state;
  };

  static String name(const eProperty p) {
    switch (p) {
    case PNone:
      return "None";
    case PMeasure:
      return "Measure";
    case PLength:
      return "Length";
    case PArea:
      return "Area";
    case PVolume:
      return "Volume";        
    case PCenter:
      return "Center";
    case PNormal:
      return "Normal";
    case PVolumeSurfaceRatio:
      return "VolumeSurfaceRatio";
    case PEnd:
    default:
      throw FatalErrorException(A_FUNCINFO,"Undefined property");
      return String();
    }
  }

  static String name(const eStorage p) {
    switch (p) {
    case PNoStorage:
      return "NoStorage";
    case PVariable:
      return "Variable";
    case PItemGroupMap:
      return "ItemGroupMap";
    default:
      throw FatalErrorException(A_FUNCINFO,"Undefined storage");
      return String();
    }
  }
};

class IGeometryMng
{
public:
  typedef VariableItemReal RealVariable;
  typedef VariableItemReal3 Real3Variable;
  typedef ItemGroupMapBaseT<Real> RealGroupMap;
  typedef ItemGroupMapBaseT<Real3> Real3GroupMap;

public:
  /** Constructeur de la classe */
  IGeometryMng() 
    {
      ;
    }
  
  /** Destructeur de la classe */
  virtual ~IGeometryMng() {};
  
public:
  //! Initialisation
  virtual void init() = 0;

  //@{ @name Geometric property management for ItemGroup 

  //! Set geometric properties on a ItemGroup
  /*! \deprecated storage must be defined explicitly */
  virtual ARCANE_DEPRECATED void addItemGroupProperty(ItemGroup group, Integer property) = 0;

  //! Set geometric properties on a ItemGroup
  virtual void addItemGroupProperty(ItemGroup group, Integer property, Integer storage) = 0;

  //! Set geometric properties on a ItemGroup with an external container (real field)
  virtual void addItemGroupProperty(ItemGroup group, IGeometryProperty::eProperty property, RealVariable var) = 0;

  //! Set geometric properties on a ItemGroup with an external container (real3 field)
  virtual void addItemGroupProperty(ItemGroup group, IGeometryProperty::eProperty property, Real3Variable var) = 0;

  //! Get set of properties of an ItemGroup
  virtual Integer getItemGroupProperty(ItemGroup group) = 0;

  //! Check if a property is activated on an ItemGroup
  virtual bool hasItemGroupProperty(ItemGroup group, Integer property) = 0;

  //! Check if a storage is available on an ItemGroup
  virtual Integer getItemGroupPropertyStorage(ItemGroup group, IGeometryProperty::eProperty property) = 0;

  //@}

  //@{ @name Access to geometric values

  //! Get geometric property values for a Real field
  virtual const RealVariable & getRealVariableProperty(ItemGroup group, IGeometryProperty::eProperty property) = 0;

  //! Get geometric property values for a Real3 field
  virtual const Real3Variable & getReal3VariableProperty(ItemGroup group, IGeometryProperty::eProperty property) = 0;

  //! Get geometric property values for a Real field
  virtual const RealGroupMap & getRealGroupMapProperty(ItemGroup group, IGeometryProperty::eProperty property) = 0;

  //! Get geometric property values for a Real3 field
  virtual const Real3GroupMap & getReal3GroupMapProperty(ItemGroup group, IGeometryProperty::eProperty property) = 0;

  //@}

  // Remove extra methods since, their usage is not qualified
  //   //@{ @name property management by group and properties
  //   //! Update property values for an ItemGroup
  //   virtual void update(ItemGroup group, Integer property) = 0;
  //   //! Reset property for an ItemGroup
  //   virtual void reset(ItemGroup group, Integer property) = 0;
  //   //@}
  
  //   //@{ @name property management by group
  //   //! Update property values for an ItemGroup
  //   virtual void update(ItemGroup group) = 0;
  //   //! Reset property for an ItemGroup
  //   virtual void reset(ItemGroup group) = 0;
  //   //@}

  //@{ @name global property management 

  //! Update property values for all ItemGroups
  virtual void update(IGeometryPolicy * policy = NULL) = 0;

  //! Reset property for all ItemGroups
  virtual void reset() = 0;
  
  //@}

  //! Get underlying geometry
  virtual IGeometry * geometry() = 0;

  //! Temporary interface to set tolerance on geometry policy
  virtual void setPolicyTolerance(bool tolerance) = 0;
};

#endif /* ARCGEOSIM_GEOMETRY_IGEOMETRYMNG_H */
