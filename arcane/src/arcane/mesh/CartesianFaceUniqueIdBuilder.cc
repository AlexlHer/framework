// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2021 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
/*---------------------------------------------------------------------------*/
/* CartesianFaceUniqueIdBuilder.cc                             (C) 2000-2021 */
/*                                                                           */
/* Construction des indentifiants uniques des faces en cartésien.            */
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#include "arcane/mesh/DynamicMesh.h"

#include "arcane/core/internal/ICartesianMeshGenerationInfo.h"

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

namespace Arcane::mesh
{

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/*!
 * \brief Construction des uniqueId() des faces pour un maillage cartésien.
 */
class CartesianFaceUniqueIdBuilder
: public TraceAccessor
{
 public:

  //! Construit une instance pour le maillage \a mesh
  CartesianFaceUniqueIdBuilder(DynamicMesh* mesh);
  virtual ~CartesianFaceUniqueIdBuilder();

 public:

  void computeFacesUniqueIdAndOwner();

 private:

  DynamicMesh* m_mesh;
  IParallelMng* m_parallel_mng;
  bool m_is_verbose;

 private:
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

CartesianFaceUniqueIdBuilder::
CartesianFaceUniqueIdBuilder(DynamicMesh* mesh)
: TraceAccessor(mesh->traceMng())
, m_mesh(mesh)
, m_parallel_mng(mesh->parallelMng())
, m_is_verbose(false)
{
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

CartesianFaceUniqueIdBuilder::
~CartesianFaceUniqueIdBuilder()
{
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void CartesianFaceUniqueIdBuilder::
computeFacesUniqueIdAndOwner()
{
  auto* cmgi = ICartesianMeshGenerationInfo::getReference(m_mesh,false);
  if (!cmgi)
    ARCANE_FATAL("No 'ICartesianMeshGenerationInfo'. The mesh is not a cartesian mesh "
                 "or was not generated by 'CartesianMeshGenerator'");

  Integer dimension = m_mesh->dimension();
  if (dimension!=2 && dimension!=3)
    ARCANE_THROW(NotSupportedException,"Bad value '{0}' for dimension. Only dimensions 2 or 3 are supported",
                 dimension);

  Int64ConstArrayView global_nb_cells = cmgi->globalNbCells();
  info() << "Dim=" << dimension << " GLOBAL_NB_CELLS=" << global_nb_cells;
  Int64 nb_cell_x = global_nb_cells[0];
  Int64 nb_cell_y = global_nb_cells[1];
  Int64 nb_cell_z = global_nb_cells[2];

  Int64 nb_face_x = nb_cell_x + 1;
  Int64 nb_face_y = nb_cell_y + 1;
  Int64 nb_face_z = nb_cell_z + 1;
  Int64 nb_face_xy = nb_face_x * nb_face_y;

  ItemInternalMap& cells_map = m_mesh->cellsMap();

  if (dimension==2){
    std::array<Int64,4> face_uids;
    ENUMERATE_ITEM_INTERNAL_MAP_DATA(iid,cells_map){
      // Récupère l'indice (I,J,K) de la maille
      Cell cell { iid->value() };
      Int64 uid = cell.uniqueId();
      Int64 y = uid / nb_cell_x;
      Int64 x = uid % nb_cell_x;
      info() << "UID=" << uid << " X=" << x << " Y=" << y
             << " N0=" << cell.node(0).uniqueId()
             << " N1=" << cell.node(1).uniqueId()
             << " N2=" << cell.node(2).uniqueId()
             << " N3=" << cell.node(3).uniqueId();
      //Int64 cell_unique_id = cell_unique_id_offset + x + y * all_nb_cell_x;
      //Int64 cell_unique_id = cell_unique_id_offset + x + y * all_nb_cell_x;
      face_uids[0] = (x+0) + ((y+0) * nb_face_x) + nb_face_xy;
      face_uids[2] = (x+0) + ((y+1) * nb_face_x) + nb_face_xy;

      face_uids[1] = (x+1) + (y+0) * nb_face_x;
      face_uids[3] = (x+0) + (y+0) * nb_face_x;
      for( int i=0; i<4; ++i ){
        info() << "CELL=" << uid << " Face=" << i << " p=" << cell.face(i).internal() << " uid=" << face_uids[i];
        cell.face(i).internal()->setUniqueId(face_uids[i]);
      }
    }
  }
  else if (dimension==3)
    ARCANE_FATAL("NYI");
  else
    ARCANE_FATAL("Invalid dimension");
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

extern "C++" void
arcaneComputeCartesianFaceUniqueId(DynamicMesh* mesh)
{
  CartesianFaceUniqueIdBuilder f(mesh);
  f.computeFacesUniqueIdAndOwner();
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

} // End namespace Arcane::mesh

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
