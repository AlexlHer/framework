// -*- tab-width: 2; indent-tabs-mode: nil; coding: utf-8-with-signature -*-
//-----------------------------------------------------------------------------
// Copyright 2000-2021 CEA (www.cea.fr) IFPEN (www.ifpenergiesnouvelles.com)
// See the top-level COPYRIGHT file for details.
// SPDX-License-Identifier: Apache-2.0
//-----------------------------------------------------------------------------
/*---------------------------------------------------------------------------*/
/* CartesianFaceUniqueIdBuilder.cc                             (C) 2000-2021 */
/*                                                                           */
/* Construction des indentifiants uniques des faces en cartésien.            */
/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

#include "arcane/mesh/DynamicMesh.h"

#include "arcane/core/internal/ICartesianMeshGenerationInfo.h"

#include <array>

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

namespace Arcane::mesh
{

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
/*!
 * \brief Construction des uniqueId() des faces pour un maillage cartésien.
 */
class CartesianFaceUniqueIdBuilder
: public TraceAccessor
{
 public:

  //! Construit une instance pour le maillage \a mesh
  CartesianFaceUniqueIdBuilder(DynamicMesh* mesh);

 public:

  void computeFacesUniqueIdAndOwner();

 private:

  DynamicMesh* m_mesh;
  IParallelMng* m_parallel_mng;
  bool m_is_verbose;
};

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

CartesianFaceUniqueIdBuilder::
CartesianFaceUniqueIdBuilder(DynamicMesh* mesh)
: TraceAccessor(mesh->traceMng())
, m_mesh(mesh)
, m_parallel_mng(mesh->parallelMng())
, m_is_verbose(false)
{
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

void CartesianFaceUniqueIdBuilder::
computeFacesUniqueIdAndOwner()
{
  auto* cmgi = ICartesianMeshGenerationInfo::getReference(m_mesh,false);
  if (!cmgi)
    ARCANE_FATAL("No 'ICartesianMeshGenerationInfo'. The mesh is not a cartesian mesh "
                 "or was not generated by 'CartesianMeshGenerator'");

  Integer dimension = m_mesh->dimension();
  if (dimension!=2 && dimension!=3)
    ARCANE_THROW(NotSupportedException,"Bad value '{0}' for dimension. Only dimensions 2 or 3 are supported",
                 dimension);

  Int64ConstArrayView global_nb_cells = cmgi->globalNbCells();
  info() << "Dim=" << dimension;
  Int64 nb_cell_x = global_nb_cells[0];
  Int64 nb_cell_y = global_nb_cells[1];
  Int64 nb_cell_z = global_nb_cells[2];
  Int64 nb_cell_xy = nb_cell_x * nb_cell_y;

  Int64 nb_face_x = nb_cell_x + 1;
  Int64 nb_face_y = nb_cell_y + 1;
  Int64 nb_face_z = nb_cell_z + 1;
  Int64 nb_face_dir_x = nb_face_x * nb_cell_y;
  Int64 nb_face_dir_y = nb_face_y * nb_cell_x;
  Int64 nb_face_dir_z = nb_cell_x * nb_cell_y;
  Int64 face_offset_z = nb_face_dir_x + nb_face_dir_y;
  Int64 nb_face_xyz = face_offset_z + nb_cell_xy;
  Int64 nb_face_xy = nb_face_dir_x + nb_face_dir_y;
  Int64 total_nb_face_xyz = (nb_face_dir_x + nb_face_dir_y) * nb_cell_z;

  info() << "NB_Cell: X=" << nb_cell_x << " Y=" << nb_cell_y << " Z=" << nb_cell_z
         << " XY=" << nb_cell_xy;
  info() << "NB_Face: X=" << nb_face_x << " Y=" << nb_face_y << " Z=" << nb_face_z
         << " NbDirX=" << nb_face_dir_x << " NbDirY=" << nb_face_dir_y  << " NbDirZ=" << nb_face_dir_z
         << " NbFaceXYZ=" << nb_face_xyz << " OffsetZ=" << face_offset_z
         << " TotalNbFaceXYZ=" << total_nb_face_xyz;

  ItemInternalMap& cells_map = m_mesh->cellsMap();
  bool is_verbose = m_is_verbose;
  is_verbose = true;
  if (dimension==2){
    // Les mailles sont des quadrangles
    std::array<Int64,4> face_uids;
    ENUMERATE_ITEM_INTERNAL_MAP_DATA(iid,cells_map){
      // Récupère l'indice (I,J) de la maille
      Cell cell { iid->value() };
      Int64 uid = cell.uniqueId();
      Int64 y = uid / nb_cell_x;
      Int64 x = uid % nb_cell_x;
      if (is_verbose)
        info() << "UID=" << uid << " X=" << x << " Y=" << y
               << " N0=" << cell.node(0).uniqueId()
               << " N1=" << cell.node(1).uniqueId()
               << " N2=" << cell.node(2).uniqueId()
               << " N3=" << cell.node(3).uniqueId();
      // Faces selon Y
      face_uids[0] = (x+0) + ((y+0) * nb_cell_x) + nb_face_dir_x;
      face_uids[2] = (x+0) + ((y+1) * nb_cell_x) + nb_face_dir_x;

      // Faces selon X
      face_uids[1] = (x+1) + (y+0) * nb_face_x;
      face_uids[3] = (x+0) + (y+0) * nb_face_x;

      for( int i=0; i<4; ++i ){
        Face face = cell.face(i);
        if (is_verbose)
          info() << "CELL=" << uid << " Face=" << i << " uid=" << face_uids[i]
                 << " N0=" << face.node(0).uniqueId()
                 << " N1=" << face.node(1).uniqueId();

        face.internal()->setUniqueId(face_uids[i]);
      }
    }
  }
  else if (dimension==3){
    // Les mailles sont des hexaèdres
    std::array<Int64,6> face_uids;
    ENUMERATE_ITEM_INTERNAL_MAP_DATA(iid,cells_map){
      // Récupère l'indice (I,J) de la maille
      Cell cell { iid->value() };
      Int64 uid = cell.uniqueId();
      Int64 z = uid / nb_cell_xy;
      Int64 v = uid - (z * nb_cell_xy);
      Int64 y = v / nb_cell_x;
      Int64 x = v % nb_cell_x;
      if (is_verbose)
        info() << "UID=" << uid << " X=" << x << " Y=" << y << " Z=" << z
               << " N0=" << cell.node(0).uniqueId()
               << " N1=" << cell.node(1).uniqueId()
               << " N2=" << cell.node(2).uniqueId()
               << " N3=" << cell.node(3).uniqueId()
               << " N4=" << cell.node(4).uniqueId()
               << " N5=" << cell.node(5).uniqueId()
               << " N6=" << cell.node(6).uniqueId()
               << " N7=" << cell.node(7).uniqueId();

      // Faces selon Z
      face_uids[0] = (x+0) + ((y+0) * nb_cell_x) + ((z+0) * nb_face_dir_z) + total_nb_face_xyz;
      face_uids[3] = (x+0) + ((y+0) * nb_cell_x) + ((z+1) * nb_face_dir_z) + total_nb_face_xyz;

      // Faces selon X
      face_uids[1] = (x+0) + ((y+0) * nb_face_x) + ((z+0) * nb_face_xy);
      face_uids[4] = (x+1) + ((y+0) * nb_face_x) + ((z+0) * nb_face_xy);

      // Faces selon Y
      face_uids[2] = (x+0) + ((y+0) * nb_cell_x) + ((z+0) * nb_face_xy) + nb_face_dir_x;
      face_uids[5] = (x+0) + ((y+1) * nb_cell_x) + ((z+0) * nb_face_xy) + nb_face_dir_x;

      for( int i=0; i<6; ++i ){
        Face face = cell.face(i);
        if (is_verbose)
          info() << "CELL=" << uid << " Face=" << i << " uid=" << face_uids[i]
                 << " N0=" << face.node(0).uniqueId()
                 << " N1=" << face.node(1).uniqueId()
                 << " N2=" << face.node(2).uniqueId()
                 << " N3=" << face.node(3).uniqueId();
        face.internal()->setUniqueId(face_uids[i]);
      }
    }
  }
  else
    ARCANE_FATAL("Invalid dimension");

  // TODO: il faut maintenant calculer les propriétaires des faces
  info() << "TODO: Need to compute face owners";
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

extern "C++" void
arcaneComputeCartesianFaceUniqueId(DynamicMesh* mesh)
{
  CartesianFaceUniqueIdBuilder f(mesh);
  f.computeFacesUniqueIdAndOwner();
}

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/

} // End namespace Arcane::mesh

/*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*/
